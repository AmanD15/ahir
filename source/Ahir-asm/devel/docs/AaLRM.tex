\documentclass{article}

\title{Aa Language Reference Manual}
\author{Madhav Desai \\ Department of Electrical Engineering \\ Indian Institute of Technology \\
	Mumbai 400076 India}

\newcommand{\Aa}{{\bf Aa}~}

\begin{document}
\maketitle

\section{Introduction}

{\bf Aa} is a low-level 
programming language for the description
of algorithms.  The control flow in
an \Aa program 
can be modeled by a petri net
of a specific class (the type-2 petri-net as
introduced in \cite{ref:SameerPhD}).  
A program in \Aa can also be viewed as a 
description of a system which reacts with 
its environment through input and output ports and 
through message queues.  Thus, an \Aa program
can either be executed on a computer, or
be mapped to a logic circuit.

In the rest of this document, we outline the
structure and the syntax of the \Aa language,
and also describe the semantics of an \Aa
program, especially the execution model and
the behaviour of the equivalent system.


\section{Program structure}


A program in \Aa consists of a sequence of
declarations and module definitions.  
\begin{verbatim}
program := ( module-definition | program-object-declaration )*
\end{verbatim}
Declarations at the program level 
can belong to one of three classes:
\begin{itemize}
\item {\bf Storage} objects declared in the program
are globally visible variables that can be read from
anywhere in the program and can be written from anywhere
in the program.
\item {\bf Pipe} objects declared in the program are
globally visible first-in-first-out buffers that can 
be read from anywhere in the program. 
written into by at most one module in the program.
\begin{itemize}
\item A pipe can be written into by at most one module
in the program, and can be read from by at most one module
in the program.
\item A pipe that is only written into in the program, but
is not read from, is assumed to have a destination outside
the program.
\item A pipe that is only read from in a program but not
written into, is assumed to have a source outside the program.
\end{itemize}
\item {\bf Constant} objects are globally visible and have
initial values which can never be altered in the program.
Thus, an assignment to a constant is an error.
\end{itemize} 

A module in \Aa is the basic unit of compilation, and
has the following structure
\begin{verbatim}
$module [module-name] 
   $in(<input-arguments>)
   $out(<output-arguments>)
$is
{
   <object-declarations>
   <sequence-of-statements>
}
\end{verbatim}
Thus, a module has a name, has input and output arguments,
declares objects and consists of a sequence of statements.
Objects (storage/pipe/constant) declared in the module are visible only in the
module body. 

Each statement in the sequence
of statements can be viewed as a transition
in a petri-net, and has a 
set of input (or source) places  and a set of output
(or sink)  places.  
The execution of the statement is triggered when
there is a token present in some subset of its source 
places and when the statement finishes execution,
a token is placed in each of its output places.

The control flow in the sequence of statements
in a module is serial in nature.  Thus each
statement has a single source place and a single
sink place, sink place of a statement being 
the source place of its successor.
The module as a whole can be viewed as having
a single entry place and a single exit place.
When a token appears in the entry place, the first
statement can trigger, and when the last statement
has finished, a token is placed in the exit
place.  

The region between \{ and \} is termed a {\bf scope}.  Thus, 
a module description defines a scope.  In this case, 
the scope has a label which is the same as the module name.
As we shall see later, the statements in the statement sequence
may in turn define scopes.  Each scope defines a name-space.  
The visibility
rules and access mechanisms between scopes will be described
in Section \ref{sec:Scopes}.


\section{Statements}
 
Statements in the module-body are can be of two kinds:
\begin{itemize}
\item Simple statements: those that have a single
entry place and a single exit place.  These are
the only statements that can occur in a module body.
These statements are further divided into 
{\em simple} statements and {\em block} statements.
\item Sub-atomic statements:  these statements
can appear only inside block statements,  and they
can have multiple source and sink places.
Examples of these statements are statements for
combining tokens (merge and join statements) and
statements for redirecting tokens (the place statement).
\end{itemize}


\subsection{Simple Statements}

Simple statements can be one of the following:
\begin{itemize}
\item An {\bf assignment} statement is of the form
\begin{verbatim}
target-ref := expression
\end{verbatim}
where {\em target-ref} either specifies a declared object
or an undeclared name.  If it is an undeclared name, then
it is an implicit variable that is attached to the
assignment statement.  No other statement can write to this
variable, but any statement can read from this variable
subject to scoping rules.  Thus, every implicit variable
is such that exactly one statement defines its value.
When control flow reaches an assignment statement, it
evaluates the expression, updates the value of the target
and passes the control flow forward (we will see what this
means in the sequel).
Some examples of simple statements are 
\begin{verbatim}
a  :=  (~b)
b  :=   (c + (d + e))
\end{verbatim}
etc.  
More details of the syntax are provided in 
Section \ref{sec:Syntax}.
\item A {\bf call} statement is of the form
\begin{verbatim}
call-spec module-name input-argument-values output-argument-targets
\end{verbatim}
The call statement thus specifies a module to which control flow
is to be passed.  The call statement may itself define new implicit
variables through its specified targets (and thus is the only
statement that can modify these newly defined implicit variables).
When control flow reaches the call statement, it forwards the
token to the called module, and finishes when the token exits
the called module.  Recursive calls and cyclical dependencies between
modules through call statements are not permitted in the \Aa language.
Here is an example of a call statement
\begin{verbatim}
// pass control to a module named foo
// foo has two inputs and three outputs
$call foo (p,q)  (r,s,t)
\end{verbatim}
More details of the syntax are provided in 
Section \ref{sec:Syntax}.
\item The {\bf null} statement does nothing, and just passes the
token onwards.  This is how it looks like
\begin{verbatim}
$null
\end{verbatim}
\end{itemize}

\subsection{Block Statements}

Block statements can be used to describe complex
control flows, and consist of a sequence of statements.
Block statements are of
the following types:
\begin{itemize}
\item {\bf Series} block statements are of the form
\begin{verbatim}
series-block-statement :=
             series-block-specifier block-name
             { 
                declarations
                sequence-of-atomic-statements
             }
\end{verbatim}
The behaviour is similar to the module, in that the control
token flows serially down the sequence of statements.
Here is an example:
\begin{verbatim}
$seriesblock [s1] 
{
   $storage b $uint<32>
   b := a
   b := ( $mux (a > c)  (b+c) (b-c))
   q := ( b * 2)
}
\end{verbatim}
In this example, the variable $b$ was declared as
a storage variable in scope s1, and hence was legally
able to be the target of multiple assignment statements.
\item {\bf Parallel} block statements are of the form
\begin{verbatim}
parallel-block-statement :=
             parallel-block-specifier block-name
             { 
                declarations
                sequence-of-atomic-statements
             }
\end{verbatim}
When a token enters the parallel block statement, it
is replicated into as many tokens as there are statements in
the sequence, and all statements are started in parallel.
When all statements have finished and released their token,
the parallel block statement
ends and a single token exits the parallel block statement (this
is essentially a fork followed by a join).
Here is an example
\begin{verbatim}
$parallelblock [p1] 
{
   b := a + c
   d := a - c
}
\end{verbatim}
The two statements will start in parallel, and the block 
will finish when both have finished.  The
order in which the two statements are executed
is {\bf not} specified.
\item {\bf Fork} block statements are generalizations of the
parallel block region in the sense that they
allow the programmer to express complex fork-join interactions.
They have the following structure:
\begin{verbatim}
fork-block-statement :=
             fork-block-specifier block-name
             {
                declarations
                sequence-of-statements
             }
\end{verbatim}
The control flow is similar to the parallel block region,
in the sense that all statements in the sequence are started
in parallel, and the fork block statement ends when all statements
in the sequence have ended.  The difference is that
fork blocks can have an additional statement which
allows the programmer to provide additional synchronization
points.  These statements are termed {\bf join} statements
and have the form
\begin{verbatim}
join-statement :=
         join-specifier list-of-labels 
          fork-specifier  list-of-statements
\end{verbatim}
The meaning of this statement is that it waits until all statements
in the list-of-labels have finished, then starts the list-of-statements
(in parallel) and finishes.  This essentially defines a node in a directed graph,
with the arcs corresponding to statements in the statement-lists.  
The join indicates the arcs (or statements) 
from whom tokens have to arrive.  When all tokens have arrived
on the incoming arcs, tokens are sent along the outgoing arcs specified
in the list of statements following the optional fork specifier.  There is an implicit fork
at the entry point to the fork block statement and an implicit join at the
end of the fork block statement.  It is thus easy to describe
an arbitrary directed graph with arbitrary forks and joins.  The only
restriction is that this directed graph must be acyclic!  This is enforced
by requiring that a join statement refers only to labels of statements
that appear before the join.
Here is an example:
\begin{verbatim}
$forkblock [f1] {
  a := (b+c)
  $seriesblock [s1] { ... }
  $seriesblock [s2] { ... }
  $seriesblock [s3] { ... }
  $join s1 s2 $fork 
      $seriesblock [s4] { ... }
  $join s3 s4
}
\end{verbatim}
In this example, the first assignment statement as well as s1, s2, s3 are 
started in parallel. When both s1 and s2 have finished, s4 is started and
when s3, s4 have joined and when the first assignment statement has
finished, the forkblock f1 finishes execution.
\item {\bf Branch} block statements are constructs which allow the programmer
to describe arbitrary sequential branching behaviour.  They 
describe a control flow in which a single token 
is active within the block.  The movement of this token is
controlled by special flow control statements.
They are structured 
as follows
\begin{verbatim}
branch-block-statement :=
             branch-block-specifier block-name
             { sequence-of-statements}
\end{verbatim}
The sequence of statements appearing in a branch block
consist of
\begin{itemize}
\item Simple statements or Block statements.
\item Switch statements: A switch statement has
the form
\begin{verbatim}
switch-statement :=
         switch-spec switch-expression
           ( expr-value  serial-statement-sequence )*
           ( default serial-statement-sequence )?
            
\end{verbatim}
The switch-expression is checked, and depending on its
value, one of the alternative statements is selected.
Thus, the incoming token to the switch statement is 
passed to one of the alternatives.  For example,
\begin{verbatim}
$switch a $when 0 $then a1 := (b + c)
          $when 1 $then a2 := (b - c)
          $default $null
$endswitch
\end{verbatim}
The control token is routed to the appropriate
choice sequence and if the token is not routed out 
of the block (by the {\bf place} statement 
described below), then the token passes to the
statement following the switch. 
\item If statements: An if statement has the form
\begin{verbatim}
if-statement :=
       if-spec test-expression 
           serial-statement-sequence
       (else
           serial-statement-sequence)?
       
\end{verbatim}
For example:
\begin{verbatim}
$if (a != 0) $then
   q := (r + s)
   t := 0
$else
   qdash :  (r - s)
$endif
\end{verbatim}
If the control token reaches the end of a selected
segment in the if statement (that is, without being
rerouted by a place statement), then the control
token is passed on to the statement immediately
following the if statement.
\item The place statement: The {\bf place} statement
defines a place with a label  into which it places
a token after it has executed.  For example,
\begin{verbatim}
$place [fastpath]
\end{verbatim}
means that the incoming token is placed in a labeled
place ``fastpath'' (the place statement never
puts a token into its default exit place).  
The token placed in ``fastpath" must be used to
trigger a unique {\bf merge} statement which is required
to depend on this labeled place in the same branch
block. If no such merge exists, or if multiple such merges exist, 
then this is an error.
\item Merge statements: A merge statement is
specified as 
\begin{verbatim}
merge-statement :=
          merge-spec label-list merge-assignments end-merge-spec
\end{verbatim}
which is to be interpreted as follows.  The labels in the label list
refer to token labels defined by {\bf place}  statements within the branch block.
Whenever a token is present in any of the places in
the label-list for a merge,
the merge statement starts and executes a series of special assignments
which multiplex values into new variables based on which arc the
token arrived from.  The merge statement then releases its token to
the next statement. 
The merge assignments inside a merge block are all of a specific
form, called the phi-statement.  A phi-statement has the following
form
\begin{verbatim}
$phi a := b $on $entry c $on loopback 
\end{verbatim}
This says that the target $a$ is to take the value of $b$ if
the merge statement was started from its entry place (ie from a
token passed from its predecessor) and is to take the value of $c$
if the merge statement was started from the place ``loopback".
Note that if the merge statement is to be triggered by a
token in its default entry place, one of the labels in the
label-list for the merge must contain the identifier \$entry.
\end{itemize}

Here is an example of a branch block constructed in this manner
\begin{verbatim}
$branchblock [b1] 
{
  $merge loopback $entry // $entry is the place
                     // into the block
                     // merge triggered by
                     // token at entry or
                     // by token in place "loop"


       $phi q := 0 on $entry r on loop 
                    // q is defined by where 
                    // the token came from
  $endmerge
  r := q + 1
  $if r < 10 $then 
       $place [loopback] // put token in place "loopback"
  $endif
}
\end{verbatim}
This is to be interpreted as follows: the merge executes
whenever a token is present in its entry place  or in 
the place labeled ``loopback''.
The merge defines variable ``q'' with a value which is
either 0 (if a token was present in the entry place)
or r (if a token was present in the ``loop'' place).
By the construction rules in an \Aa program, it is
impossible for there to be a token present in more
than one input place to a merge.
\end{itemize}

Thus, an \Aa program is constructed as a collection of modules,
each of which is a sequence of statements.  The use of series,
parallel, fork and branch block
statements enables the programmer to describe a highly concurrent
structured system with complex branching behaviour.  
The resulting control flow structure is a
type-2 petri-net with provable liveness and safety properties \cite{ref:SameerPhD}.

\section{Scoping Rules} \label{sec:Scopes}

An \Aa program is made of modules which in turn contain statements
and so on.  The program thus has a hierarchy of scopes with each
scope being contained in another (except for the program itself,
which is not contained in any scope).

The rules for scoping are as follows:
\begin{enumerate}
\item A declared variable defined in a scope is visible
in all descendant scopes. In addition
\begin{itemize}
\item If $x$ is a storage or pipe variable defined in a scope, then
there can be no other variable named $x$ in any of the scopes
contained in this scope.
\item If $x$ is an input or output argument of a module, then
there can be no other variable named $x$ declared in any of
the descendant scopes of this module.
\end{itemize}
\item A reference to a variable $b$ in a scope X is resolved by checking
whether the variable is defined in that scope, and if not found there,
by checking in the scope that contains the scope X, and so on.
\item A scope can read from variables that are defined in descendant
scopes.  
\item A scope can read from variables that are defined in ancestor scopes.
\item A scope can only write to one of the following:
\begin{itemize}
\item an implicit variable defined in the scope.
\item a storage or pipe variable defined in the scope or an ancestor
of the scope.
\item an output argument of a module of which the scope is a descendant.
In this case, there can be at most one statement in the entire module
which writes to this output argument.
\end{itemize}
\end{enumerate}

A variable reference in a statement may be specified 
as follows
\begin{verbatim}
a            look for variable a in current scope; 
             if not found look in the parent.

:a           same as the previous case

#:a          look for variable a starting from the parent of
             the current scope.

%p:a         look for variable a starting from the child scope 
             with label p (child scope of the current scope).

##:a         look for variable starting from the parent of
             the parent of the current scope.

%p%q:a       look for variable starting from the child scope 
             with label q of the child scope with label p of 
             the current scope

a[10]        look for a storage variable a defined in the 
             current scope.  If not found, look for it in
             the parent scope, and so on.  If eventually found, 
             access the corresponding element of the array.
\end{verbatim}
Thus, a generic variable reference has the form 
\begin{verbatim} 
    scope-reference : variable-reference 
\end{verbatim} 
and the scoping rules forbid a scope from accessing variables
which are not defined in either an ancestor or a descendant
of the scope.

\section{Types}

Types in \Aa can be either scalars or arrays.

Scalar types can be one of 
\begin{itemize}
\item Unsigned integers:  An unsigned integer type
has a width parameter and is specified as 
\begin{verbatim}
$uint<width>
\end{verbatim}
The width parameter can be any positive number.
Values corresponding to this type are to be
viewed as unsigned integers represented by 
a binary sequence of the specified width.
\item Signed integers:  A signed integer type
has a width parameter and is specified as 
\begin{verbatim}
$int<width>
\end{verbatim}
The width parameter can be any positive number.
Values corresponding to this type are to be
viewed as integers maintained in the
two-s complement form  by 
a binary sequence of the specified width.
\item Floats: A float is parametrized by
two integers, the width of the exponent,
and the width of the mantissa.  
The specification is
\begin{verbatim}
$float<exponent,mantissa>
\end{verbatim}
where the exponent and mantissa must be positive
integers.  The float is represented by 
a word with $exponent+mantissa+1$ bits
(with the additional bit needed for the sign).
The standard IEEE 754 float and double
precision representations correspond
to
\begin{verbatim}
$float<8><23> 
\end{verbatim}
and
\begin{verbatim}
$float<11><52> 
\end{verbatim}
respectively.
\item Pointers:  A pointer type has the form
\begin{verbatim}
$pointer<ref-width>
\end{verbatim}
A value of this type is considered to be
a handle to an item whose width is specified
by ref-width (ref-width must be positive).  
A pointer value can only be
referred to and {\bf can never} be used in a
unary, binary or ternary expression.
\end{itemize}


Array types in \Aa have the form
\begin{verbatim}
$array[d1][d2]..[dk] $of <scalar-type-spec>
\end{verbatim}
The number of dimensions $k$ must be positive (there is
no limit on this number), and the scalar type spec
must specify one of the scalar types described above.

\section{Expressions}

Expressions in \Aa fall into the following classes
\begin{itemize}
\item {\bf Object References}: references to an object
which have the form
\begin{verbatim}
<scope-specifier>:<object-specifier>
\end{verbatim}
The scope specifier can either specify a
parent scope of the scope in which the expression appears,
or a child scope of the scope in which the 
expression appears.   The scope-specifier can be omitted
if the reference is to be resolved in the same scope
as the expression.
\item {\bf Unary} Expressions:  There are two
possible unary expressions.  The {\bf type-cast}
expression is of the form
\begin{verbatim}
($cast (<type-spec>)  <expression>)
\end{verbatim}
For example
\begin{verbatim}
($cast ($uint<10>) ##:a)
\end{verbatim}
The type-cast expression takes the value of the
specified expression and converts it to a value
of the specified type.
The {\bf bit-wise complement} expression is of the form
\begin{verbatim}
( ~ <expression> )
\end{verbatim}
The symbol for the complement is the same
as the one used in the C programming language,
and the evaluation of the expression proceeds in the
usual way.
\item {\bf Binary} Expressions: These are of the
form
\begin{verbatim}
(<expression> <operation-id>  <expression>)
\end{verbatim}
The following binary operations are supported
\begin{verbatim}
// arithmetic operators
PLUS              + 
MINUS             - 
MUL               * 
DIV               / 
SHL               <<
SHR               >> 

// bit-wise logical operators
NOT               ~     
OR                |     
AND               &    
XOR               ^   
NOR               ~|     
NAND              ~&    
XNOR              ~^   

// comparison operators
EQUAL             ==
NOTEQUAL          !=
LESS              < 
LESSEQUAL         <=
GREATER           > 
GREATEREQUAL      >=
\end{verbatim}
The evaluation of a binary expression proceeds in
the usual way.
\item {\bf Ternary} Expressions:  There is only one
form for the ternary expression.
\begin{verbatim}
( $mux <test-expression>  <true-expression> <false-expression> )
\end{verbatim}
The test-expression is evaluated, and if true, the true-expression
is evaluated, and if false, the false-expression is evaluated.
\end{itemize}

\section{Foreign Modules}

A module can be marked as foreign by using the
\$foreign keyword.
\begin{verbatim}
$foreign $ module [GetValue]
	$in (ptr $pointer<32>)
	$out (val $uint<32>)
\end{verbatim}
The \Aa compiler then considers that the module GetValue
is defined ``elsewhere'' and does not try to link to it
directly.  This linking is done outside by other tools which
use the results of the \Aa compilation process.

\section{Examples}

Here is a very simple program
\begin{verbatim}
// an array of 32-bit unsigned integers.
$storage mem $array<1024> of $uint<32> 
$module [sel_mod]
   $in (a $uint<32> b $uint<10>)
   $out (c $uint<32>)
$is
{
   c := (mem[b] + a)
   mem[b] := c
}
\end{verbatim}
This consists of a single module, which accumulates
a value into an array position.


An example which is a little bit more complicated:
\begin{verbatim}
// an array of 32-bit unsigned integers.
$storage mem $array<1024> $of $uint<32> 

// module returns the sum of mem[I] from
// I=low to I=high
$module [sum_mod]
    $in (low $uint<10> high $uint<10>)
    $out (sum $uint<32>)
$is
{
 
   d := (high-low)  
   mp := ((high-low)/2)


   $branchblock[trivcheck]
    {
       // d from parent scope
       $if (d > 0) $then  
           // do two summations in parallel
           // parallel summations
           $parallelblock[parsum]
           {
               $branchblock[sb1]{
                    $storage  I $uint<10> := 0
                    $merge $entry loopback
                       $phi s := 0 $on $entry  s1 $on loopback
		    $endmerge
                    $if (I < mp) $then
                       I := (I+1)
                       s1 := ($mux (I == 0)  0 (s + mem[I]))
                       $place [loopback]
                    $endif
               } 
               $branchblock[sb2]{
                    $storage  J $uint<10> := 0
                    J := (mp + 1)
                    $merge $entry loopback
                       $phi s := 0 $on $entry s1 $on loopback
		    $endmerge
                    $if (J < high) $then
                         J := (J+1)
                         s1 := ($mux (J == (mp+1))  0 (s + mem[J]))
                         $place [loopback]
                    $endif
               } 
           }
 
           // combine results from parallel statement above
           snontriv := (%parsum%sb1:s  + %parsum%sb2:s)
           $place [nontrivsum]
      $else

           // summation is trivial 
           striv := mem[low]
           $place [trivsum]
      $endif
      $merge nontrivsum trivsum
         // which sum do you pick? depends on which path was taken
         $phi sum := snontriv $on nontrivsum striv $on trivsum
      $endmerge
    }

}
\end{verbatim}
This example describes an algorithm which computes the sum of
a section of an array by dividing the problem into two partial
summations. 

\section{Syntax} \label{sec:Syntax}

The syntax for \Aa follows the following
principles
\begin{itemize}
\item All keywords begin with the \$ sign.
\item The region between \{ and \} defines a new scope.
\item Statements are space separated (no semicolons at all).
\item Expressions are fully parenthitized.  Thus
$(a + b)$ is a legal expression, but $a+b$ is not.
\end{itemize}


The parser is implemented using 
an LL(k) parser (written as rules to be parsed by antlr2 \cite{ref:antlr2}).
The grammar for the parser is (using the EBNF notation) given below. 
\input{AaParser}

This is the set of tokens recognized by the lexical analyzer (or lexer).
\input{AaLexer}

\begin{thebibliography}{99}
\bibitem{ref:SameerPhD}
Sameer D. Sahasrabuddhe,
``A competitive pathway from high-level programs to hardware,''
Ph.D. thesis, IIT Bombay, 2009.

\bibitem{ref:antlr2}
http://www.antlr2.org.
\end{thebibliography}

\end{document}
