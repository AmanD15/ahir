/*
    a grammar to describe the interface to 
    a VHDL system generated by the vc2vhdl
    flow

 */


header "post_include_cpp" {
}

header "post_include_hpp" {
#include <SystemInterface.h>
#include <antlr/RecognitionException.hpp>
ANTLR_USING_NAMESPACE(antlr)
}

options {
	language="Cpp";
}

class AaParser extends Parser;

options {
	// go with LL(4) grammar
	k=4;
	defaultErrorHandler=true;
} 
{
    void reportError(RecognitionException &re )
 	{
        std::cerr << "Error: Parsing Exception: " + re.toString() << std::endl;
 	}
}


//-----------------------------------------------------------------------------------------------
// sYSTEM : SYSTEM LBRACE (pIPE | fUNCTION )* RBRACE
//-----------------------------------------------------------------------------------------------
aA_Program[SystemInterface* si]
{
	SystemPipeRecord* pr;
        SystemFunctionRecord* fr;
}
    :

	SYSTEM LBRACE
	 	( ( pr = pIPE { si->Add_Pipe_Record(pr);}) 
			|
		  ( fr = fUNCTION { si->Add_Function_Record(fr);} ))*
        RBRACE
    ;



//-----------------------------------------------------------------------------------------------
// pIPE : PIPE pname (IN | OUT) reqname ackname dataname datawidth
//-----------------------------------------------------------------------------------------------
pIPE returns[SystemPipeRecord* pr]
{
	pr = new pIPE();
}
    : 
	PIPE pid:SIMPLE_IDENTIFIER {pr->Set_Name(pid->getText();}
		( (IN {pr->Set_Mode("in");}) | (OUT {pr->Set_Mode("out")))
		rid: SIMPLE_IDENTIFIER {pr->Set_Req_Name(rid->getText());}
		aid: SIMPLE_IDENTIFIER {pr->Set_Ack_Name(aid->getText());}
		did: SIMPLE_IDENTIFIER {pr->Set_Data_Name(did->getText());}
		wid: UINTEGER {pr->Set_Data_Width(atoi(did->getText().c_str()));}
    ;

//-----------------------------------------------------------------------------------------------
// fUNCTION : FUNCTION fname startname finname LPAREN (identifier width)* RPAREN LPAREN (identifier width)* RPAREN
//-----------------------------------------------------------------------------------------------
fUNCTION returns [SystemFunctionRecord* sr]
{
  sr = new SystemFunctionRecord();
}
:
	FUNCTION fid:SIMPLE_IDENTIFIER {sr->Set_Name(fid->getText());}
		stid:SIMPLE_IDENTIFIER {sr->Set_Start_Name(stid->getText());}
		finid:SIMPLE_IDENTIFIER {sr->Set_Fin_Name(finid->getText());}
		LPAREN
			(iargid:SIMPLE_IDENTIFIER iwid:SIMPLE_IDENTIFIER
				{ sr->Add_Argument("in",
						iargid->getText(),
						atoi(iwid->getText().c_str()));
				}
			)*
		RPAREN
		LPAREN
			(oargid:SIMPLE_IDENTIFIER owid:SIMPLE_IDENTIFIER
				{ sr->Add_Argument("out",
						oargid->getText(),
						atoi(owid->getText().c_str()));
				}
			)*
		RPAREN
		
;

//----------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------


// lexer rules
class AaLexer extends Lexer;

options {
	k = 6;
	testLiterals = true;
	charVocabulary = '\3'..'\377';
	defaultErrorHandler=true;
}

// language keywords (all start with $)
FUNCTION       : "$function";
PIPE           : "$pipe";
IN            : "$in";
OUT           : "$out";


// data format
UINTEGER          : DIGIT (DIGIT)*;


// White spaces (only "\n" is newline)
WHITESPACE: (	' ' |'\t' | '\f' | '\r' | '\n' { newline(); } ) 
{ 
	$setType(ANTLR_USE_NAMESPACE(antlr)Token::SKIP); 
}
;

// Comment: anything which follows //
SINGLELINECOMMENT:
( 
 "//" (~'\n')* '\n' { newline(); }
 ) 
{ 
	$setType(ANTLR_USE_NAMESPACE(antlr)Token::SKIP); 
}
;


// Identifiers
SIMPLE_IDENTIFIER options {testLiterals=true;} : ALPHA (ALPHA | DIGIT | '_')*; 



// base
protected ALPHA: 'a'..'z'|'A'..'Z';
protected DIGIT:'0'..'9';

