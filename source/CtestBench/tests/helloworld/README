This example illustrates how you can use your "normal" software
to verify the hardware generated out of the AhirV2 flow.

We take the following program (in main.c)
//////////////////////////////////////////////////////////////////////
#include <stdlib.h>
#include <stdint.h>

float read_float32(const char *id);
uint32_t read_uint32(const char *id);

void write_float32(const char *id, float data);
void write_uint32(const char *id, uint32_t data);


int foo(int a)
{
	
	int b;
	b = read_uint32("inpipe");
	write_uint32("midpipe",a+b);

	return(a);
}

int bar(int a)
{
	int b;

	b = read_uint32("midpipe");
	write_uint32("outpipe",(a+b));

	return(a);
}
//////////////////////////////////////////////////////////////////////


This program describes a system consisting of two
independent agents foo and bar, which communicate with
the environment and also with each other through pipes.

The following multi-threaded program (testbench.c) could
be used to verify it.
//////////////////////////////////////////////////////////////////////
#include <pthread.h>
#include <signal.h>

void Exit(int sig)
{
	fprintf(stderr, "## Break! ##\n");
	exit(0);
}



typedef struct _FnArgs FnArgs;
struct _FnArgs
{
	int a;
	int* ret_val;
};

void *foo_(void* fargs)
{
   *(((FnArgs*)fargs)->ret_val) = foo(((FnArgs*)fargs)->a);
}

void *bar_(void* fargs)
{
   *(((FnArgs*)fargs)->ret_val) = bar(((FnArgs*)fargs)->a);
}

void *write_pipe_(void* a)
{
	write_uint32("inpipe",*((int*)a));
}

void *read_pipe_(void* a)
{
	*((int*)a) = read_uint32("outpipe");
}

int main(int argc, char* argv[])
{
	signal(SIGINT,  Exit);
  	signal(SIGTERM, Exit);

	int pipe_in, pipe_out, foo_ret, bar_ret;
	if(argc < 2)
	{
		fprintf(stderr, "specify seed\n");
		return(0);
	}
	int seed = atoi(argv[1]);
	pipe_in = seed;

	// in parallel, start foo and bar.
	pthread_t foo_t, bar_t, wpipe_t, rpipe_t;
	FnArgs foo_args, bar_args;

	foo_args.a = seed;
	foo_args.ret_val = &foo_ret;

	bar_args.a = seed;
	bar_args.ret_val = &bar_ret;

	pthread_create(&foo_t,NULL,&foo_,(void*)&foo_args);
	pthread_create(&bar_t,NULL,&bar_,(void*)&bar_args);
	pthread_create(&wpipe_t,NULL,&write_pipe_,(void*)&pipe_in);
	pthread_create(&rpipe_t,NULL,&read_pipe_,(void*)&pipe_out);


	pthread_join(foo_t,NULL);
	pthread_join(bar_t,NULL);
	pthread_join(wpipe_t,NULL);
	pthread_join(rpipe_t,NULL);
}
//////////////////////////////////////////////////////////////////////

We would like to use this same testbench.c (more or less) to verify
the hardware.  foo and bar move to hardware and the hardware system
interacts with the outside world through the arguments of foo and bar
and the pipes inpipe and outpipe.

Here is how we do it:  Look at the file compile.sh

# first three steps are the same as usual
clang -std=gnu89 -emit-llvm -c main.c
llvm-dis main.o
llvm2aa main.o |vcFormat >  main.o.aa

# ok. here the -C option is used: it generates C-stubs
# for all functions mapped to hardware
Aa2VC -C main.o.aa | vcFormat > main.o.aa.vc

# generate the hardware.
# the -C option generates a VHDL testbench which can connect
# to software.
vc2vhdl -C -t foo -t bar -f main.o.aa.vc | vhdlFormat > main_o_aa_vc.vhdl


OK. now copy main_o_aa_vc.vhdl to the vhdl/ directory
and also the vhdlCStubs.c and vhdlCStubs.h files generated by
Aa2VC -C to the vhdl/ directory.  
We continue the README in the vhdl/ directory.

