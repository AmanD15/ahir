\documentclass{article}

\title{On verifying AhirV2 generated VHDL using software testbenches}
\author{Madhav Desai \\ Department of Electrical Engineering \\ Indian Institute of Technology \\
	Mumbai 400076 India}

\newcommand{\Aa}{{\bf Aa}~}
\newcommand{\vC}{{\bf vC}~}

\begin{document}
\maketitle


The AhirV2 tool chain can be used to convert parts of a C program to VHDL
(essentially, some of the functions in a program are mapped to VHDL).
To verify the resulting VHDL, one would like to simulate it in a
VHDL simulator (such as Modelsim from Mentor Graphics).  The most
natural way to do this is to use the original program itself
as a testbench for this purpose.

\begin{itemize}
\item Stubs are created for the set of functions which are mapped to  
VHDL by the AhirV2 flow.
\item The software testbench is compiled and linked with these stubs.
\item Whenever a stub function is called, it tries to connect with
a server created by the VHDL simulation process.
\item The VHDL simulation process listens for calls from the stubs
and exchanges data between the stubs and the actual VHDL being simulated.
\end{itemize}


\section{An example}

Consider the following program (lets say it is in file ``prog.c''):
\begin{verbatim}
#include <stdlib.h>
#include <stdint.h>
#include <stdio.h>
#include <iolib.h>

uint32_t sum;

void set_sum(uint32_t x)
{
    sum = x;
}

uint32_t get_sum()
{
    return(sum);
}

void accumulate()
{
    while(1)
    {
        int nxt = read_uint32("in_data");
#ifdef SW
        printf("read %u\n", nxt);
#endif
        sum = (sum + nxt);
        write_uint32("out_data",sum);
#ifdef SW
        printf("wrote %u\n", sum);
#endif
    }
}

\end{verbatim}

This program describes a {\em system} which listens
for data on a pipe ``in\_data'', and sends data
out on a pipe ``out\_data''.  The incoming data
is accumulated into the variable {\em sum}, and
there are two methods to set and get the value
of {\em sum}.

Now to test this program, we can write a test-bench
such as this one (lets call this file ``testbench.c'').
\begin{verbatim}
#include <pthread.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>

#ifdef SW 
// for the read_*/write_* methods
#include <iolib.h>
#include "prog.h"
#else
// includes for the read_*/write_* methods
// as well as stubs for functions moved
// to hardware.
#include "vhdlCStubs.h"
#endif

void Exit(int sig)
{
   fprintf(stderr, "## Break! ##\n");
   exit(0);
}

void *accumulate_(void* fargs)
{
   accumulate();
}

void *write_pipe_(void* a)
{
   write_uint32_n("in_data",(uint32_t*)a, 10);
}

void *read_pipe_(void* a)
{
   read_uint32_n("out_data",(uint32_t*)a, 10);
}

int main(int argc, char* argv[])
{
        signal(SIGINT,  Exit);
        signal(SIGTERM, Exit);

        uint32_t data_in[10], data_out[10];
        int i;
	
        // initial value of sum.
        set_sum(1); 

        for(i = 0; i < 10; i++)
        {
          data_in[i] = i;
        }

        pthread_t acc_t, wpipe_t, rpipe_t;

#ifdef SW
        pthread_create(&acc_t,NULL,&accumulate_,NULL);
#endif
        pthread_create(&wpipe_t,NULL,&write_pipe_,(void*)data_in);
        pthread_create(&rpipe_t,NULL,&read_pipe_,(void*)data_out);

        pthread_join(wpipe_t,NULL);
        pthread_join(rpipe_t,NULL);


        fprintf(stdout,"from out_data, we read ");
        for(i=0; i < 10; i++)
          fprintf(stdout," %u ", data_out[i]);
        fprintf(stdout,"\n");
        fprintf(stdout,"final sum is %u\n", get_sum());

#ifdef SW
        pthread_cancel(acc_t);
#endif
}

\end{verbatim}
The test-bench sets an initial value for sum, and starts
three threads: one to write data to pipe in\_data, one
to read data from pipe out\_data, and one to run the
accumulate function.  After the last data is read back
from out\_data, the test-bench gets the value of sum
and prints it out. 


Obviously, we would prefer to use the same test-bench
to verify that the VHDL system generated from ``prog.c'' 
functions correctly.  
The difference is that instead of using methods in iolib,
the test-bench now uses methods in SocketLib.  Further, the
VHDL is executed in a VHDL simulator; the simulator communicates
with the testbench using sockets.
The {\em ifdef's} in the test-bench and the system program
indicate the difference between the pure software version
of the system-test-bench combination and the hardware-software
version.  

The following Makefile builds a software-only testbench
executable, and also converts the system described in prog.c
to VHDL.  The same testbench can be used to test the VHDL
also.
\begin{verbatim}
# build software version of testbench 
# (to check the "desired behaviour")
IOLIB_INCLUDE=../../iolib/include
IOLIB_LIB=../../iolib/lib
SOCKETLIB_INCLUDE=../../CtestBench/include
SOCKETLIB_LIB=../../CtestBench/lib
VHDL_LIB=../../vhdl
VHDL_VHPI_LIB=../../CtestBench/vhdl
all: SW HW 

# compile with SW defined.
# note the use of IOLIB in building the testbench.
SW: prog.c prog.h testbench.c 
        gcc -c -DSW -I$(IOLIB_INCLUDE) prog.c
        gcc -c -DSW -I$(IOLIB_INCLUDE) testbench.c
        gcc -o testbench_sw prog.o testbench.o -L$(IOLIB_LIB) -lio -lpthread

# five steps from C to vhdl simulator.
HW: c2llvmbc llvmbc2aa aa2vc vc2vhdl vhdlsim

# C to llvm byte-code.. use clang.
c2llvmbc: prog.c prog.h testbench.c
        clang -std=gnu89 -I$(IOLIB_INCLUDE) -emit-llvm -c prog.c
        #llvm-dis prog.o
        opt -O3	 prog.o > prog.opt.o
        llvm-dis prog.opt.o

# llvm byte-code to Aa..
llvmbc2aa:  prog.opt.o
        llvm2aa prog.opt.o | vcFormat >  prog.opt.o.aa

# Aa to vC
aa2vc: prog.opt.o.aa
        Aa2VC -O -C prog.opt.o.aa | vcFormat > prog.opt.o.aa.vc

# vC to VHDL
vc2vhdl: prog.opt.o.aa.vc
        vc2vhdl -C -e ahir_system -w -s ghdl\
                -T accumulate -t set_sum -t get_sum\
                -f prog.opt.o.aa.vc 
        vhdlFormat < ahir_system.unformatted_vhdl > ahir_system.vhdl
        vhdlFormat < ahir_system_test_bench.unformatted_vhdl\
                    > ahir_system_test_bench.vhdl
        
# build testbench and ghdl executable
# note the use of SOCKETLIB in building the testbench.
vhdlsim: ahir_system.vhdl ahir_system_test_bench.vhdl\
           testbench.c vhdlCStubs.h vhdlCStubs.c
        gcc -c vhdlCStubs.c -I./ -I$(SOCKETLIB_INCLUDE)
        gcc -c testbench.c -I./ -I$(SOCKETLIB_INCLUDE)
        gcc -o testbench_hw testbench.o vhdlCStubs.o\
               -L$(SOCKETLIB_LIB) -lSocketLib -lpthread
        ghdl --clean
        ghdl --remove
        ghdl -i --work=ahir  $(VHDL_LIB)/ahir.vhdl
        ghdl -i --work=ieee_proposed  $(VHDL_LIB)/ieee_proposed.vhdl
        ghdl -i --work=work $(VHDL_VHPI_LIB)/Utility_Package.vhdl
        ghdl -i --work=work $(VHDL_VHPI_LIB)/Vhpi_Package.vhdl
        ghdl -i --work=work ahir_system.vhdl
        ghdl -i --work=work ahir_system_test_bench.vhdl
        ghdl -m --work=work -Wc,-g -Wl,-L$(SOCKETLIB_LIB)\
                 -Wl,-lVhpi ahir_system_test_bench 
        
clean:
        rm -f *.o* *.cf *.*vhdl vhdlCStubs.*\
             *.vcd in_data* out_data* testbench_sw\
              testbench_hw ahir_system_test_bench\
              vhpi.log

PHONY: all clean	
\end{verbatim}
To test the software, run testbench\_sw.  To verify the hardware (using
the VHDL simulator GHDL), start testbench\_sw in one shell, and then start ahir\_system\_test\_bench
in a different shell.
\end{document}
