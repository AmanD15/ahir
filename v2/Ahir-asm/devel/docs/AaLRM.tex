\documentclass{article}

\title{Aa Language Reference Manual}
\author{Madhav Desai \\ Department of Electrical Engineering \\ Indian Institute of Technology \\
	Mumbai 400076 India}

\newcommand{\Aa}{{\bf Aa}~}
\newcommand{\vC}{{\bf vC}~}

\begin{document}
\maketitle

\section{Introduction}

{\bf Aa} is a programming language for the 
description of algorithms.   The control-flow
in an \Aa program corresponds to a petri net
of a specific class (the type-2 petri-net as
introduced in \cite{ref:SameerPhD}).  
The data-flow is constructed using static
single-assignment variables (which can be assigned to only once),
storage objects, messaging pipes and constants.
Pointers to storage objects can be created
and manipulated (pointer arithmetic, dereferencing
etc.) in the usual way.  

A program in \Aa can also be viewed as a 
description of a system which reacts with 
its environment through input and output ports.
Thus, an \Aa program can either be executed on a 
computer, or be mapped to a logic circuit.

In the rest of this document, we outline the
structure and the syntax of the \Aa language,
and also describe the semantics of an \Aa
program, especially the execution model and
the behaviour of the equivalent system.


\section{Program structure}


A program in \Aa consists of a sequence of
declarations and module definitions.  
\begin{verbatim}
program := ( module-definition | program-variable-declaration )*
\end{verbatim}
Program variable declarations
can belong to one of three classes as described in Section \ref{sec:Objects}.

A module in \Aa is the basic unit of compilation, and
has the following structure
\begin{verbatim}
$module [module-name] 
   $in(<input-arguments>)
   $out(<output-arguments>)
$is
{
   <object-declarations>
   <sequence-of-statements>
}
\end{verbatim}
Thus, a module has a name, has input and output arguments,
declares objects and consists of a sequence of statements.
Objects (storage/pipe/constant) declared in the module are visible only in the
module body.   For example:
\begin{verbatim}
$module [sum] 
   $in (a: $uint<32> b: $uint<32>) 
   $out (c : $uint<32>)
$is
{
   c := (a+b)
}
\end{verbatim}
In this example, {\em sum} is 
a module which has two inputs and a single output.
The type of the inputs and the output is 
\begin{verbatim}
$uint<32>
\end{verbatim}
which is an unsigned 32-bit integer (More details
on types are given in Section \ref{sec:Types}).

Each statement in the sequence
of statements can be abstractly 
viewed as a region
in a petri-net,  and has a 
set of input (or source) places  and a set of output
(or sink)  places.  
The execution of the statement is triggered when
there is a token present in every place in some specified subsets
of its source 
places and when the statement finishes execution,
a token is placed in some specified subset of its sink places.   

The control flow in the sequence of statements
in a module is serial in nature.  Thus each
statement has a single source place and a single
sink place, with the sink place of a statement being 
the source place of its successor.
The module as a whole can be viewed as having
a single entry place and a single exit place.
When a token appears in the entry place, the first
statement can trigger, and when the last statement
has finished, a token is placed in the exit
place.  

The region between \{ and \} is termed a {\bf scope}.  Thus, 
a module description defines a scope.  In this case, 
the scope has a label which is the same as the module name.
As we shall see later, the statements in the statement sequence
may in turn define scopes.  Each scope defines a name-space.  
The visibility
rules and access mechanisms between scopes will be described
in Section \ref{sec:Scopes}.

\section{Program Variables} \label{sec:Objects}

Variables in  the program can belong to the following classes:
\begin{itemize}
\item {\bf Storage} variables declared in the program
can be written into from multiple
points in the program.  When declared at the program
scope, storage variables are visible throughout
the program.  Storage variables can be thought of 
as memory locations which can be accessed from different
points in the program.
A storage variable declaration has the form
\begin{verbatim}
$storage <var-name>: <var-type> 
\end{verbatim}
For example
\begin{verbatim}
$storage mempool: $array [1024] $of $uint<32>
\end{verbatim}
\item {\bf Pipe} variables declared at the program scope
are globally visible buffers (which
can be defined to be either first-in-first-out (FIFO) or
last-in-first-out (LIFO)) that can 
be read from anywhere in the program and can be
written into from anywhere in th program.  A pipe
is a FIFO (or FIFO) buffer with a specified number of
slots.  A write to a pipe succeeds
only if there is an empty slot in the FIFO (a successful
write uses up an empty slots.  A read
from the pipe succeeds only if there is at
least one occupied slot in the pipe (a successful read
creates an empty slot in the pipe). 
Thus, pipes can be used to model queues as
well as stacks, and also provide a mechanism for synchronization and
for message passing in an \Aa program.
\begin{itemize}
\item A pipe that is only written into in the program, but
is not read from, is assumed to have a destination outside
the program.  Such a pipe is an output port of the
program.
\item A pipe that is only read from in a program but not
written into, is assumed to have a source outside the program.
Such a pipe is an input port of the program.
\end{itemize}
A pipe declaration has the form
\begin{verbatim}
($lifo)? $pipe <pipe-name>: <pipe-type>  ($depth <integer>)?
\end{verbatim}
For example
\begin{verbatim}
$pipe myfifo: $uint<32> $depth 16 // 16-slot queue
$lifo $pipe mystack: $uint<32> $depth 4 // 4-slot stack
\end{verbatim}
\item {\bf Constant} variables declared at
the program scope are globally visible and have
initial values which can never be altered in the program.
Thus, an assignment to a constant is an error.
A constant declaration has the form
\begin{verbatim}
$constant <constant-name>: <constant-type> := <initial-value>
\end{verbatim}
For example
\begin{verbatim}
$constant wordlength: $uint<32> := 16
\end{verbatim}
\item {\bf Implicit} or {\bf Static Single Assignment}
variables are created by statements in the \Aa program
(as described below in Section \ref{sec:Statements}).
These are analogous to registers that can be written
into only from one point,  but can be
read from several points in the program.
Implicit variables are not declared, but are defined
by the statements which write to them.
\end{itemize} 


\section{Statements} \label{sec:Statements}
 
Statements in the module-body are can be of two kinds:
\begin{itemize}
\item Complete or atomic statements: these are statements
which have a single
entry place and a single exit place.  These are
the only statements that can occur in a module body.
These statements are further divided into 
{\em simple} statements and {\em block} statements.
\item Incomplete or sub-atomic statements:  these statements
can appear only inside block statements,  and they
can have multiple source and sink places.
Examples of these statements are statements for
combining tokens (merge and join statements) and
statements for redirecting tokens (the place statement).
\end{itemize}


\subsection{Complete Statements}

Complete statements can be one of the following:
\begin{itemize}
\item An {\bf assignment} statement is of the form
\begin{verbatim}
target-ref := expression
\end{verbatim}
where {\em target-ref} either specifies a declared object
or an undeclared name.  If it is an undeclared name, then
it is an implicit variable that is attached to the
assignment statement.  No other statement can write to this
variable, but any statement can read from this variable
subject to scoping rules.  Thus, every implicit variable
is such that exactly one statement defines its value.
When control flow reaches an assignment statement, it
evaluates the expression, updates the value of the target
and passes the control flow forward (we will see what this
means in the sequel).
Some examples of assignment statements are 
\begin{verbatim}
a  :=  (~b)
b  :=   (c + (d + e))
\end{verbatim}
etc.   Expressions can be {\em unary},
{\em binary} or {\em ternary}, and are
described in detail in Section \ref{sec:Expressions}.
Details of the syntax are provided in 
Section \ref{sec:Syntax}.
\item A {\bf call} statement is of the form
\begin{verbatim}
call-spec module-name input-arguments output-arguments
\end{verbatim}
The call statement thus specifies a module to which control flow
is to be passed.  The call statement may itself define new implicit
variables through its specified targets (and thus is the only
statement that can modify these newly defined implicit variables).
When control flow reaches the call statement, it forwards the
token to the called module, and finishes when the token exits
the called module.  Recursive calls and cyclical dependencies between
modules through call statements are not permitted in the \Aa language.
Here is an example of a call statement
\begin{verbatim}
// pass control to a module named foo
// foo has two inputs and three outputs
$call foo (p q)  (r s t)
\end{verbatim}
Here $p,q,r,s,t$ can be expressions.

Complete atomic statements can have a guard predicate
specified, so that they are executed only if the guard
predicate is true.  This is specified either by
\begin{verbatim}
$guard ( <guard-variable> )  <statement-spec>
\end{verbatim}
or 
\begin{verbatim}
$guard ( ~ <guard-variable> )  <statement-spec>
\end{verbatim}
For example
\begin{verbatim}
$guard (sel_add) r := (a + b)
\end{verbatim}
or
\begin{verbatim}
$guard (~ sel_add) $call afun (a b) (r)
\end{verbatim}


More details of the syntax are provided in 
Section \ref{sec:Syntax}.

\item The {\bf null} statement does nothing, and just passes the
token onwards.  This is how it looks like
\begin{verbatim}
$null
\end{verbatim}
\end{itemize}

\subsection{Complete Block Statements}

Block statements can be used to describe complex
control flow,  and consist of a sequence of statements.
Block statements are of
the following types:
\begin{itemize}
\item {\bf Series} block statements are of the form
\begin{verbatim}
series-block-statement :=
             series-block-specifier block-name
             { 
                declarations
                sequence-of-atomic-statements
             } [(variable-exports)]
\end{verbatim}
The behaviour is similar to the module, in that the control
token flows serially down the sequence of statements.
Here is an example:
\begin{verbatim}
$seriesblock [s1] 
{
   $storage b $uint<32>
   b := a
   b := ( $mux (a > c)  (b+c) (b-c))
   q := ( b * 2)
} ( q => q )
\end{verbatim}
In this example, the variable $b$ was declared as
a storage variable in scope s1, and hence was legally
able to be the target of multiple assignment statements.
The optional export specification
\begin{verbatim}
( q => q )
\end{verbatim}
after the curly brace \} specifies that the variable
$q$ defined inside the block $s1$ is visible outside
the block as $q$ (so that other scopes can use this
variable, see Section \ref{sec:Scopes} below).
\item {\bf Parallel} block statements are of the form
\begin{verbatim}
parallel-block-statement :=
             parallel-block-specifier block-name
             { 
                declarations
                sequence-of-atomic-statements
             } [(variable-exports)]
\end{verbatim}
When a token enters the parallel block statement, it
is replicated into as many tokens as there are statements in
the sequence, and all statements are started in parallel.
When all statements have finished and released their token,
the parallel block statement
ends and a single token exits the parallel block statement (this
is essentially a fork followed by a join).
Here is an example
\begin{verbatim}
$parallelblock [p1] 
{
   b := a + c
   d := a - c
}
\end{verbatim} %$
The two statements will start in parallel, and the block 
will finish when both have finished.  The
order in which the two statements are executed
is {\bf not} specified.
\item {\bf Fork} block statements are generalizations of the
parallel block region, and they allow the programmer to express 
complex fork-join interactions.
They have the following structure:
\begin{verbatim}
fork-block-statement :=
             fork-block-specifier block-name
             {
                declarations
                sequence-of-statements
             } [(variable-exports)]
\end{verbatim}
The control flow is similar to the parallel block region,
in the sense that all statements in the sequence are started
in parallel, and the fork block statement ends when all statements
in the sequence have ended.  The difference is that
fork blocks can have an additional statement which
allows the programmer to provide additional synchronization
points.  These statements are termed {\bf join} statements
and have the form
\begin{verbatim}
join-statement :=
         join-specifier list-of-labels 
          fork-specifier  list-of-statements
\end{verbatim}
The meaning of this statement is that it waits until all statements
in the list-of-labels have finished, then starts the list-of-statements
(in parallel) and finishes.  This essentially defines a node in a directed graph,
with the arcs corresponding to statements in the statement-lists.  
The join indicates the arcs (or statements) 
from whom tokens have to arrive.  After all tokens have arrived
on the incoming arcs, tokens are sent along the outgoing arcs specified
in the list of statements following the optional fork specifier.  There is an implicit fork
at the entry point to the fork block statement and an implicit join at the
end of the fork block statement.  It is thus easy to describe
an arbitrary directed graph with arbitrary forks and joins.  The only
restriction is that this directed graph must be acyclic!  This is enforced
by requiring that a join statement refers only to labels of statements
that appear before the join.
Here is an example:
\begin{verbatim}
$forkblock [f1] {
  a := (b+c)
  $seriesblock [s1] { ... }
  $seriesblock [s2] { ... }
  $seriesblock [s3] { ... }
  $join s1 s2 $fork 
      $seriesblock [s4] { ... }
  $join s3 s4
}
\end{verbatim}
In this example, the first assignment statement as well as s1, s2, s3 are 
started in parallel. When both s1 and s2 have finished, s4 is started and
when s3, s4 have joined and when the first assignment statement has
finished, the forkblock f1 finishes execution.
\item {\bf Branch} block statements are constructs which allow the programmer
to describe arbitrary sequential branching behaviour.  They 
describe a control flow in which a single token 
is active within the block.  The movement of this token is
controlled by special flow control statements.
A branch block is constructed 
as follows
\begin{verbatim}
branch-block-statement :=
             branch-block-specifier block-name
             { 
		 branch-block-statement-sequence 
	     } [(variable-exports)]
\end{verbatim}
The sequence of statements appearing in a branch block
consist of
\begin{itemize}
\item Simple statements or Block statements.
\item Switch statements: A switch statement has
the form
\begin{verbatim}
switch-statement :=
         switch-spec switch-expression
           ( expr-value  branch-block-statement-sequence )*
           ( default branch-block-statement-sequence )?
         end-switch-spec
\end{verbatim}
The switch-expression is checked, and depending on its
value, one of the alternative statements is selected.
Thus, the incoming token to the switch statement is 
passed to one of the alternatives.  For example,
\begin{verbatim}
$switch a $when 0 $then a1 := (b + c)
          $when 1 $then a2 := (b - c)
          $default $null
$endswitch
\end{verbatim}
The control token is routed to the appropriate
choice sequence and if the token is not routed out 
of the block (by the {\bf place} statement 
described below), then the token passes to the
statement following the switch. 
\item If statements: An if statement has the form
\begin{verbatim}
if-statement :=
       if-spec test-expression 
           branch-block-statement-sequence
       (else
           branch-block-statement-sequence)?
       end-if-spec
       
\end{verbatim}
For example:
\begin{verbatim}
$if (a != 0) $then
   q := (r + s)
   t := 0
$else
   qdash :=  (r - s)
$endif
\end{verbatim}
If the control token reaches the end of a selected
segment in the if statement (that is, without being
rerouted by a place statement), then the control
token is passed on to the statement immediately
following the if statement.
\item The place statement: The {\bf place} statement
identifies a place which will contain 
a token after the place statemet has executed.  For example,
\begin{verbatim}
$place [fastpath]
\end{verbatim}%$
means that the incoming token is placed in a labeled
place {\bf fastpath} (the place statement never
puts a token into its default exit place).  
The token placed in {\bf fastpath} must be used to
trigger a unique {\bf merge} statement which is required
to depend on this labeled place in the same branch
block. If no such merge exists, or if multiple such merges exist, 
then this is an error.
\item Merge statements: A merge statement is
specified as 
\begin{verbatim}
merge-statement :=
          merge-spec label-list merge-assignments end-merge-spec
\end{verbatim}
which is to be interpreted as follows.  The labels in the label list
refer to token labels defined by {\bf place}  statements within the branch block.
Whenever a token is present in any of the places in
the label-list for a merge,
the merge statement starts and executes a series of special assignments
which multiplex values into targets based on which arc the
token arrived from.  The merge statement then releases its token to
the next statement. 
\begin{itemize}
\item 
The merge assignments inside a merge block are all of a specific
form, called the phi-statement.  A phi-statement has the following
form
\begin{verbatim}
phi-spec target-expr := expr1 on-spec place-spec-1  [expr2 on-spec place-spec-2 ... ]
\end{verbatim}
For example:
\begin{verbatim}
$phi a := b $on $entry c $on loopback 
\end{verbatim}
This says that the target $a$ is to take the value of $b$ if
the merge statement was started from its entry place (from a
token passed from its predecessor) and is to take the value of $c$
if the merge statement was started from the place ``loopback''.
Note that if the merge statement is to be triggered by a
token in its default entry place, one of the labels in the
label-list for the merge must contain the identifier \$entry.
The target of a phi-statement must be an implicit variable
(declared by the statement itself, not a storage or a pipe
object).
\end{itemize}
\end{itemize}

Here is an example of a branch block constructed in this manner
\begin{verbatim}
$branchblock [b1] 
{
  $merge loopback $entry // $entry is the entry place
                         // of the merge statement.
                         // this merge is triggered by
                         // a token entering it from
                         // its predecessor or by  
                         // a token in the place "loopback"


       $phi q := 0 on $entry r on loop 
                    // q is defined by where 
                    // the token came from
  $endmerge
  r := (q + 1)
  $if (r < 10) $then 
       $place [loopback] // put token in place "loopback"
  $endif
} (r => r)
\end{verbatim}%$
This is to be interpreted as follows: the merge executes
whenever a token is present in its entry place  or in 
the place labeled {\bf loopback}
The merge defines variable {\bf q} with a value which is
either 0 (if a token was present in the entry place)
or r (if a token was present in the ``loop'' place).
By the construction rules in an \Aa program, it is
impossible for there to be a token present in more
than one input place to a merge.  The final export
makes $r$ directly visible as $r$  in the parent scope of the
branch-block.
\end{itemize}

\subsection{Pipelinable-loops: the {\bf dopipeline-while} construct}

The \Aa language provides a single construct for describing loops.
The form of the construct is
\begin{verbatim}
  $dopipeline
     $merge $entry $loopback
       <phi-statements>
     $endmerge
     atomic-statement-sequence
  $while <condition-expression>
\end{verbatim}
The do-while statement can appear only in branch-blocks.  Control enters
the do-while from a predecessor in the branch-block, and stays in the
do-while as long as the condition-expression is false.  The \$loopback
place is used to repeat the loop-body.  The leading merge statement
in the do-while is used to merge the control-flow coming in either from
the entry to the do-while or from the loopback place.

The downstream tools will always attempt to pipeline the do-while loop by
starting the next iteration while the current one is still in progress.
Dependency analysis on values in the loop-body is used to determine the
extent of loop pipelining.  While doing the pipelining, one can specify
two parameters as follows
\begin{verbatim}
  $dopipeline $depth 8 $buffering 2
    ...
  $while ....
\end{verbatim}
This specifies that up to 8 iterations of the loops will be kept alive
in hardware, and the amount of buffering per operation will be kept to
2.

Note that it is always possible to describe
a do-while loop using a branch-block, and this is what should be done
if loop-pipelining is not desired.



Thus, an \Aa program is constructed as a collection of modules,
each of which is a sequence of statements.  The use of series,
parallel, fork and branch block
statements enables the programmer to describe a highly concurrent
structured system with complex branching behaviour.  
The resulting control flow structure is a
petri-net with provable liveness and safety properties \cite{ref:SameerPhD}.

\section{Scoping Rules} \label{sec:Scopes}

An \Aa program is made of modules which in turn contain statements
and so on.  The program thus has a hierarchy of scopes 
(except for the program, each scope is delimited by \{ and \}) with each
scope being contained in another (except for the program itself,
which is not contained in any scope).

The rules for scoping are as follows:
\begin{enumerate}
\item A declared variable defined in a scope is visible
in all descendent scopes. 
\item A reference to a variable $b$ in a scope X is resolved by checking
whether the variable is defined in that scope, and if not found there,
by checking in the scope that contains the scope X, and so on.
\item A scope can read from variables that are defined in descendant
scopes.  
\item A scope can export a variable defined within its scope to
its parent scope.   The name  of the exported variable must not
clash with the name of any other variable visible in the
parent scope.
\item A scope can read from variables that are defined in ancestor scopes.
\item A scope can only write to one of the following:
\begin{itemize}
\item an implicit variable defined in the scope.
\item a storage or pipe variable defined in the scope or an ancestor
of the scope.
\item an output argument of a module of which the scope is a descendant.
In this case, there can be at most one statement in the entire module
which writes to this output argument.
\end{itemize}
\end{enumerate}

A variable reference in a statement may be specified 
as follows
\begin{verbatim}
a            look for variable a in current scope; 
             if not found look in the parent.

:a           same as the previous case

../:a        look for variable a starting from the parent of
             the current scope.

%p:a         look for variable a starting from the child scope 
             with label p (child scope of the current scope).

../../:a     look for variable starting from the parent of
             the parent of the current scope.

%p%q:a       look for variable starting from the child scope 
             with label q of the child scope with label p of 
             the current scope

a[10]        look for a storage variable a defined in the 
             current scope.  If not found, look for it in
             the parent scope, and so on.  If eventually found, 
             access the corresponding element of the composite
             object.
\end{verbatim}
Thus, a generic variable reference has the form 
\begin{verbatim} 
    scope-reference : variable-reference 
\end{verbatim} 
and the scoping rules forbid a scope from accessing variables
which are not defined in either an ancestor or a descendant
of the scope (the export mechanism should be used if this
is needed).

\section{Types} \label{sec:Types}

Types in \Aa can be either scalar types or composite types.

Scalar types can be one of 
\begin{itemize}
\item Unsigned integers:  An unsigned integer type
has a width parameter and is specified as 
\begin{verbatim}
$uint<width>
\end{verbatim}
The width parameter can be any positive number.
Values corresponding to this type are to be
viewed as unsigned integers represented by 
a binary sequence of the specified width.
\item Signed integers:  A signed integer type
has a width parameter and is specified as 
\begin{verbatim}
$int<width>
\end{verbatim}
The width parameter can be any positive number.
Values corresponding to this type are to be
viewed as integers maintained in the
two-s complement form  by 
a binary sequence of the specified width.

\item Pointers:  A pointer is an unsigned
integer with a default pointer width
(set to 32 for now), which specifies the
type of object to which it points.
For example
\begin{verbatim}
$pointer< $uint<32> > 
\end{verbatim}
is a pointer which refers to a storage
object of type \begin{verbatim}$uint<32>\end{verbatim}
\item Floats: A float is parametrized by
two integers, the width of the exponent,
and the width of the mantissa.  
The specification is
\begin{verbatim}
$float<exponent,mantissa>
\end{verbatim} %$
where the exponent and mantissa must be positive
integers.  The float is represented by 
a word with $exponent+mantissa+1$ bits
(with the additional bit needed for the sign).
The standard IEEE 754 float and double
precision representations correspond
to
\begin{verbatim}
$float<8,23> 
\end{verbatim}
and
\begin{verbatim}
$float<11,52> 
\end{verbatim}
respectively.  Currently, these are the
only float types that are supported.
\end{itemize}

Composite types in \Aa can be either
array types or record types.
\begin{itemize}
\item 
Array types in \Aa have the form
\begin{verbatim}
$array [d1][d2]...[dn] $of <element-type-spec>
\end{verbatim} %$
The values $ d1,d2, \ldots dn$ must
be positive integers, and element-type-spec
must refer to a type.
For example, 
\begin{verbatim}
$array [10][10] of $array [10] $of $uint<32>
\end{verbatim}
is a two-dimensional array type whose
elements are one dimensional arrays of 32-bit
unsigned integers.
\item
Record types in \Aa have the form
\begin{verbatim}
$record <type-1> <type-2> ... <type-n>
\end{verbatim}
An element of such a record type is
an aggregate whose first element is of type
type-1, second element is of type type-2 and so on.
For example:
\begin{verbatim}
$record <$uint<32> > <$array [10] $of $uint<32> > 
\end{verbatim}
\item Named record types are used to avoid the circular
reference problem (for example, when a record has a pointer to
itself).
\begin{verbatim}
$record [myrec] <$uint<32> >  <$pointer<myrec> >
\end{verbatim}
defines a record type with name myrec, one of whose
fields is a pointer to myrec.
\end{itemize}



\section{Expressions} \label{sec:Expressions}


Expressions in \Aa fall into the following classes
\begin{itemize}
\item Constant literal references.
\item Simple object references.
\item Indexed object references.
\item Pointer de-reference expressions.
\item Address-of expressions.
\item Unary expressions.
\item Binary expressions.
\item Ternary expressions.
\end{itemize}

\subsection{Constant literal references} 

Constants can be specified in one of many
ways, depending on their type.
\begin{itemize}
\item Integers can be specified in their
decimal form, as for example 
\begin{verbatim}
23
-8
\end{verbatim}
or in binary form, as for example
\begin{verbatim}
_b10111
\end{verbatim}
When specified in binary form, the twos-complement
value of the integer being specified should be
used.
\item Floats are specified in the exponentiated
form
\begin{verbatim}
_f2.3000e+10
_f-1.354e+10
\end{verbatim}
where the mantissa has to have exactly one digit
to the left of the decimal point.
\item Composite constants are specified
as a space separated list of values.
\begin{verbatim}
( 12 32 43 10)
( (1 5) (2 8) (9 100) )
\end{verbatim}
etc.  The elements are listed in 
row major form.  Thus a[2][2] is
listed as
\begin{verbatim}
a[0][0] a[0][1] a[1][0] a[1][1]
\end{verbatim}
\end{itemize}

\subsection{Simple object references} 

References to an object have the form
\begin{verbatim}
<scope-specifier>:<object-specifier>
\end{verbatim}
The scope specifier can either specify a
parent scope of the scope in which the expression appears,
or a child scope of the scope in which the 
expression appears (as described in Section \ref{sec:Scopes}).  
The scope-specifier can be omitted
if the reference is to be resolved starting from the same scope
as the expression.
For example:
\begin{verbatim}
../:a
\end{verbatim}

\subsection{Indexed object references}

These have the form
\begin{verbatim}
<scope-specifier>:<root-object-specifier>[i1][i2]...[im]
\end{verbatim}
The scope and root-object-specifier are interpreted in the
same manner as before.  The indices $i1,i2, \ldots im$
must be non-negative integers.   The 
object-specifier must be one of
\begin{itemize}
\item A storage object whose type is composite.  For
example, if $a$ is a storage object whose
type is a two-dimensional composite type, then 
\begin{verbatim}
a[0][1]
\end{verbatim}
is interpreted in the usual manner.  Thus, when
the root-object-specifier is a declared storage
object, the indexed expression evaluates to an
element of the object.
\item A scalar object of type pointer.  For example if $ptr$ is a pointer
to an object of type $T$, then
\begin{verbatim}
ptr[1]
\end{verbatim}
is a pointer which will point to the adjacent object
of type T if we assume that ptr points to an array
of objects of type $T$.  This is similar to the following
evaluation in {\bf C}
\begin{verbatim}
int* ptr;     // ptr points to some int a[i].
ptr = ptr[1]  // ptr now points to a[i+1] 
\end{verbatim}
Now, if type T is a one-dimensional array type,
say
\begin{verbatim}
$array [10] of $uint<32>
\end{verbatim}
then the following expression makes sense
\begin{verbatim}
ptr[1][2]
\end{verbatim}
and is similar to the following evaluation in {\bf C}
\begin{verbatim}
int a[10][10];
ptr = &a[0]      // points to a[0] which is
                 // array of 10 integers
ptr = ptr[1][2]; // ptr points to a[1][2]
\end{verbatim} 
Thus, the evaluation of an indexed expression
whose root is a pointer evaluates to a
pointer of some element type.
\end{itemize}

\subsection{Pointer de-reference expressions}

If {\bf ptr} is a pointer to a scalar object,
then the expression 
\begin{verbatim}
->(ptr)
\end{verbatim}
refers to the value of the object pointed to
by {\bf ptr}.
Such an expression can occur {\bf only} as 
the target or source of a simple assignment statement.
For example
\begin{verbatim}
a := ->(ptr)
->(ptr) := (a+1)
\end{verbatim}

\subsection{Address-of expressions}

If {\bf a} is a declared {\bf storage} object,
then
\begin{verbatim}
@(a)
\end{verbatim}
is a pointer which points to {\bf a}.  Such 
an expression can occur {\bf only} as a source
of a simple assignment statement.
For example
\begin{verbatim}
ptr := @(a)
\end{verbatim}

\subsection{Unary expressions}

These can be of three types:
\begin{itemize}
\item 
The {\bf cast}
expression is of the form
\begin{verbatim}
($cast (<type-spec>)  <expression>)
\end{verbatim} %$
For example
\begin{verbatim}
($cast ($uint<10>) ../:a)
\end{verbatim}
The cast expression takes the value of the
specified expression and converts it to a value
of the specified type.  This is equivalent
to a type-cast in {\bf C}, as for example
in
\begin{verbatim}
float a;
int b = (int) a;
\end{verbatim}

\item 
The {\bf bitcast}
expression is of the form
\begin{verbatim}
($bitcast (<type-spec>)  <expression>)
\end{verbatim} %$
For example
\begin{verbatim}
($bitcast ($uint<10>) a)
\end{verbatim}
The bitcast expression takes takes the bits
corresponding to the value of the specified expression
and treats them as being of the specified cast type.
This is similar to the following in {\bf C}
\begin{verbatim}
float a;
int b = *((int*) &a);
\end{verbatim}
The destination type need not
be the same size as the source type (higher
order bits are truncated or padded with 0
as necessary).
\item 
The {\bf bit-wise complement} expression is of the form
\begin{verbatim}
( ~ <expression> )
\end{verbatim}
The symbol for the complement is the same
as the one used in the C programming language,
and the evaluation of the expression proceeds in the
usual way.
\end{itemize}

The parentheses around a unary expression are
{\bf required}.


\subsection{Binary expressions}

These are of the
form
\begin{verbatim}
(<expression> <operation-id>  <expression>)
\end{verbatim}
The following binary operations are supported
\begin{verbatim}
// arithmetic operators
PLUS              + 
MINUS             - 
MUL               * 
DIV               / 
SHL               <<
SHR               >> 

// bit-wise logical operators
NOT               ~     
OR                |     
AND               &    
XOR               ^   
NOR               ~|     
NAND              ~&    
XNOR              ~^   

// comparison operators
EQUAL             ==
NOTEQUAL          !=
LESS              < 
LESSEQUAL         <=
GREATER           > 
GREATEREQUAL      >=

// concatenation operator
CONCATENATION     &&
     c = (a && b) means that the bits of
     a and b are concatenated to produce
     the bits of c.  a,b must be of type
     $uint<>

// bit-select operator
BITSELECT         []
    c = (a [] i) means that c gets the
    value of the bit of a with index i 
    (index 0 is the least significant bit)
\end{verbatim}
The evaluation of a binary expression proceeds in
the usual way.  Note that when specifying an 
expression, you {\bf must} use parentheses around
each expression.

\subsection{Ternary expressions}

There is only one
form for the ternary expression.
\begin{verbatim}
( $mux <test-expression>  <true-expression> <false-expression> )
\end{verbatim}%$
The test-expression is evaluated, and if true, the true-expression
is evaluated, and if false, the false-expression is evaluated.
Note the parentheses delimiting the expression.
For example
\begin{verbatim}
($mux a (b+1) (c+d))
\end{verbatim}


\section{Storage variables and Memory Spaces}

An \Aa program can contain declarations to storage objects.  These
storage objects are grouped into memory spaces using
the following rule: two storage objects must be in the same
memory space if there is a de-referenced pointer in the
program which can point to either of these two storage objects.

To understand this concept, consider the following
example
\begin{verbatim}
$module [foo] 
  $in (a: $uint<32>)
  $out (b: $uint<32>) 
$is
{
   $storage u: $uint<32>
   $storage v: $uint<32>
   $storage w: $uint<32>
   $storage ptr: $pointer< $uint<32> >
   w := a
   ptr := @(u)
   ->(ptr) := w
   ptr := @(v)
   ->ptr := u
   b := u
}
\end{verbatim}
Now consider the storage variable {\bf ptr}, which can hold a value which
is a pointer to either {\bf u} or a pointer to {\bf v}.  Thus,
{\bf u} and {\bf v} must belong to the same memory space.
However, {\bf w} can sit in a memory space by itself.  The
store accesses implied by the $->(ptr)$ will point to the
memory space which contains {\bf u} and {\bf v}.


\subsection{Pointers from ``outside´´? }

What should we do in the following case?
\begin{verbatim}
$module [foo]
   $in (a : $uint<32>)
   $out (b: $uint<32>)
$is
{
   $storage u: $uint<32> 
   $storage ptr: $uint<32>
   ptr := ($bitcast ($pointer<$uint<32> >) a)
   tmp := ->(ptr)
   ptr := @(u)
   ->(ptr) := tmp
   b := u
}
\end{verbatim}
In this case, {\bf ptr} takes the value of $a$,
and as a pointer, it must point to 
an {\bf external} object.  Since ptr can 
point to this external object and also to {\bf u},
the external object and {\bf u} must be kept in
the same memory space.  In this case, there
are two possible solutions: either the external
object needs
to be made internal, and moved {\bf inside} the system,
or, the object {\bf u} must be moved outside the system
and be made part of the outside world.
This is done by the {\bf AaLinkExtMem} utility
which is described in a separate document.


\section{Inline and Macro Modules}

By default, each distinct module in an \Aa program
is eventually implemented as a separate VHDL entity
by downstream AhirV2 tools (though downstream
tools are free to instantiate multiple
copies of this entity).  

However, in order to give the \Aa programmer
more flexibility,  a module in \Aa may be marked
to be inlined or substituted into the program
at the point of the call.  The AhirV2 utility
{\bf AaOpt} is responsible for this substitution.


\subsection{Inlined Modules}

An inlined module is substituted into the
point of a call to it in a three-step manner.
The input arguments are sampled at the point
of the call, the body of
the module is invoked and the output arguments
are transferred.  The semantics of an inlined
function call are defined by this three step
procedure.  The input arguments are sampled
at the point of the call, and the output
arguments are updated at the termination of
the call.

For example, the following
program 
\begin{verbatim}
$inline $module [add] $in (a: $uint<32> b: $uint<32>)
    $out (c: $uint<32>) $is
{
    c := (a+b)
}  

$module [add_check] $in (p: $uint<32> q: $uint<32>) 
    $out (r : $uint<32>) $is
{
    $call add (p q) (r)
}
\end{verbatim}
is translated to
\begin{verbatim}
$module [add_check]
$in ( p : $uint<32>   q : $uint<32>  )
$out ( r : $uint<32>  )
$is
{
  $seriesblock[add_18] 
  {
    $parallelblock[InArgs] 
    {
      add_18_a := p
      add_18_b := q
    }
    ( add_18_a => add_18_a add_18_b => add_18_b )
    $seriesblock[body] 
    {
      add_18_c := (add_18_a + add_18_b)
    }
    (  add_18_c => add_18_c )
    $parallelblock[OutArgs] 
    {
      r := add_18_c
    }
    ( r => r )
  }
  ( r => r )
}
\end{verbatim}
The three step substitution of add into add\_check
is clearly seen.


\subsection{Macro Modules}

A module defined as a macro (described below)
is directly substituted at the point of a call
to it.  That is, all references to input and
output arguments
are replaced by references to the corresponding
expression passed to the called function.  
The semantics are equivalent to a MACRO instantiation
in programming languages such as C/C++.

For example:
\begin{verbatim}
$macro $module [shift] $in (a: $uint<32>) 
    $out (c: $uint<32>) $is
{
    c := a 
}  

$pipe inpipe: $uint<32>
$pipe midpipe: $uint<32>
$pipe outpipe: $uint<32>

$module [shift_check] $in () 
    $out () $is
{
    $call shift (inpipe) (midpipe)
    $call shift (midpipe) (outpipe)
}

\end{verbatim}
is equivalent to 
\begin{verbatim}
$pipe  inpipe : $uint<32>  $depth 1 
$pipe  midpipe : $uint<32>  $depth 1 
$pipe  outpipe : $uint<32>  $depth 1 
$module [shift_check]
$in ()
$out ()
$is
{
  $seriesblock[shift_14] 
  {
    midpipe := inpipe
  }
  $seriesblock[shift_17] 
  {
    outpipe := midpipe
  }
}
\end{verbatim}
The two calls to shift are replaced by
series blocks with input/output arguments
replaced by the expressions passed to them
at the point of the call.

Since it is possible to pass a pipe as an 
argument to a call, a macro-module is permitted
to violate the rule that there should
be at most one write to an interface object
within a module.

\section{Foreign Modules}


A module can be marked as foreign by using the

\$foreign keyword.
\begin{verbatim}
$foreign $ module [GetValue]
	$in (ptr $pointer<32>)
	$out (val $uint<32>)
\end{verbatim}

The \Aa compiler then considers that the module GetValue
is defined ``elsewhere'' and does not try to link to it
directly.  This linking is done outside by other tools which
use the results of the \Aa compilation process.

\section{Examples}


Here is a very simple program
\begin{verbatim}
// an array of 32-bit unsigned integers.
$storage mem: $array<1024> of $uint<32> 
$module [sel_mod]
   $in (a:$uint<32> b:$uint<10>)
   $out (c:$uint<32>)
$is
{
   t := (mem[b] + a)
   mem[b] := t
   c := t
}
\end{verbatim}
This consists of a single module, which accumulates
a value into an array position.

An example which is a little bit more complicated:
\begin{verbatim}
// an array of 32-bit unsigned integers.
$storage mem:$array[1024] $of $uint<32>   

// module returns the sum of mem[I] from
// I=low to I=high
$module [sum_mod]
    $in (low:$uint<10> high:$uint<10>)
    $out (sum:$uint<32>)
$is
{
   d := (high-low)  
   mp := ((high-low)/2)

   $branchblock[trivcheck]
    {
       // d from parent scope
       $if (d > 0) $then  
           // do two summations in parallel
           // parallel summations
           $parallelblock[parsum]
           {
               $branchblock[sb1]{
                    $storage  I:$uint<10>
                    $merge $entry loopback
                       $phi s := 0 $on $entry  s1 $on loopback
                    $endmerge
                    $if (I < mp) $then
                       I := (I+1)
                       s1 := ($mux (I == 0)  0 (s + mem[I]))
                       $place [loopback]
                    $endif
               } 
               $branchblock[sb2]{
                    $storage  J:$uint<10>
                    J := (mp + 1)
                    $merge $entry loopback
                       $phi s := 0 $on $entry s1 $on loopback
                    $endmerge
                    $if (J < high) $then
                         J := (J+1)
                         s1 := ($mux (J == (mp+1))  0 (s + mem[J]))
                         $place [loopback]
                    $endif
               } 
           }
 
           // combine results from parallel statement above
           snontriv := (%parsum%sb1:s  + %parsum%sb2:s)
           $place [nontrivsum]
      $else

           // summation is trivial 
           striv := mem[low]
           $place [trivsum]
      $endif
      $merge nontrivsum trivsum
         // which sum do you pick? depends on which path was taken
         $phi sum := snontriv $on nontrivsum striv $on trivsum
      $endmerge
    }
}
\end{verbatim} 
This example describes an algorithm which computes the sum of
a section of an array by dividing the problem into two partial
summations. 

\section{Syntax} \label{sec:Syntax}

The syntax for \Aa follows the following
principles
\begin{itemize}
\item All keywords begin with the \$ sign.
\item The region between \{ and \} defines a new scope.
\item Statements are space separated (no semicolons at all).
\item Expressions are fully parenthitized.  Thus
$(a + b)$ is a legal expression, but $a+b$ is not.
\end{itemize}

The parser is implemented using 
an LL(k) parser (written as rules to be parsed by antlr2 \cite{ref:antlr2}).
The grammar for the parser is (using the EBNF notation) given in 
the html file {\bf AaParser.html} which is part of this distribution. 
The set of tokens recognized by the lexical analyzer (or lexer).
is available in the html file {\bf AaLexer.html}.

\begin{thebibliography}{99}
\bibitem{ref:SameerPhD}
Sameer D. Sahasrabuddhe,
``A competitive pathway from high-level programs to hardware,''
Ph.D. thesis, IIT Bombay, 2009.

\bibitem{ref:antlr2}
http://www.antlr2.org.
\end{thebibliography}

\end{document}
