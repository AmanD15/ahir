$pipe in_data  : $uint<32> $depth 2
$pipe out_data : $uint<32> $depth 2

$pipe spl_in_data  : $uint<32> $depth 2
$pipe spl_out_data : $uint<32> $depth 2


$pipeline $depth 5 $buffering 2 $fullrate
	$module  [echo] $in (a: $uint<32>) $out (b: $uint<32>) $is
{
	b := a $buffering 2
	$attribute delay 4
}


$module [call_dependency_check_daemon] $in() $out () $is
{


	$branchblock[lOoP] {
		$dopipeline $depth 15 $buffering 4 
		$fullrate

		$merge $entry $loopback $endmerge

		X0 := in_data
		X1 := in_data
		X2 := in_data
		X3 := in_data

		$call echo (X0) (X00)
		$call echo (X1) (X11)
		$call echo (X2) (X22)
		$call echo (X3) (X33)

		out_data := X00
		out_data := X11
		out_data := X22
		out_data := X33

		$while 1
	}
}

$storage p q: $uint<32>

$module [setp] $in (X: $uint<32>) $out () $is {
	p := X
}
$module [copyp] $in () $out () $is {
	q := p 
}
$module [getq] $in () $out (X: $uint<32>) $is {
	X := q
}


$module [special_call_check_daemon] $in() $out () $is
{


	$branchblock[lOoP] {

		$merge $entry loopback $endmerge

		X0 := spl_in_data
		X1 := spl_in_data

		$call setp (X0) () $mark A
		$call copyp () () $mark B $synch (A)
		$call getq () (X00) $synch (B)

		$call setp (X1) () $mark C
		$call copyp () () $mark D $synch (C)
		$call getq () (X11) $synch (D)

		spl_out_data := X00
		spl_out_data := X11

		$place [loopback]
	}
}
