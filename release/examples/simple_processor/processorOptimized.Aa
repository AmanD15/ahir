// Aa code produced by llvm2aa (version 1.0)
$pipe out_port : $uint<16> $depth 1
$storage mem:$array [64] $of $uint<16>
$storage reg:$array [16] $of $uint<16>
$storage pc: $uint<16>
$module [run] 
$in ()
$out ()
$is 
{
  $branchblock [body] 
  {
    pc := 0
    $dopipeline $depth 32 $buffering 2

    $merge $entry $loopback 
	$phi halt := ($bitcast($uint<1>) 0) $on $entry nhalt $on $loopback
	$phi written_r_val := ($bitcast($uint<16>) 0) $on $entry new_r_val $on $loopback
	$phi written_r_index := ($bitcast($uint<16>) 0) $on $entry r1 $on $loopback 
	$phi written_r_flag  := ($bitcast($uint<1>) 0) $on $entry updates_r1 $on $loopback 
    $endmerge
        
        pc_val := pc  // 0

	ir    := mem[pc_val] // 1
	enpc   := (pc_val + 1) // 1 

  	op := (ir >> 12) // 2
  	r1 := ((ir >> 8) & _h000f) // 2  // get the first register */
  	r2 := ((ir >> 4) & _h000f) // 2  // get the second register */
  	r3 := (ir & _h000f)        // 2  // get the third register */
  	imm := (ir & _h00ff)       // 2 // get the immediate value */
  	offs := (($mux (imm > 127) (128 - imm)  imm) - 1)  //3 // get the offset, and subtract 1 because
                                                  // the PC has already moved to next location */
	

        bypass_r1 := (written_r_flag & (r1 == written_r_index))
        bypass_r2 := (written_r_flag & (r2 == written_r_index))
        bypass_r3 := (written_r_flag & (r3 == written_r_index))

	op0 := (op == 0) op1 := (op == 1) op2 := (op == 2) op3 := (op == 3)  
        op4 := (op == 4) op5 := (op == 5) op6 := (op == 6) op7 := (op ==7)	
        op8 := (op == 8) op9 := (op == 9) op10 := (op == 10) op14 := (op == 14)	 // 3

        needs_r2  := ( ( (op1 | op2) | (op3 | op4 ) ) | op7 )  // 4
 	$guard (needs_r2) r2_val := ($mux bypass_r2 written_r_val reg[r2]) // 5

	needs_r3 :=  ( (op1 | op2) | (op3 | op4 ) )  // 4
 	$guard (needs_r3) r3_val := ($mux bypass_r3 written_r_val reg[r3]) // 5

	needs_r1 := (((op4 | op9) | (op5 | op10)) | op14) // 4
	$guard (needs_r1) r1_val := ($mux bypass_r1 written_r_val reg[r1]) // 5

        updates_r1 := ( ( (op1 | op2) | (op3 | op5 ) ) | (op6 | op7 ) ) // 4
	
	nhalt := ($mux op0 1 0) // 5

	$guard (op1)  op1_r1  := (r2_val + r3_val)   // 6

	$guard (op2)  op2_r1 := (r2_val - r3_val)  // 6

	$guard (op3)  op3_addr   := (r2_val + r3_val) // 6
        $guard (op3)  op3_r1    := mem[op3_addr]  // 7

	$guard (op4)  op4_addr := (r2_val + r3_val) // 6
        $guard (op4)  mem[op4_addr] := r1_val // 7

	$guard (op5)  op5_r1 := ((r1_val & _hff00)  | imm) // 6
	
	$guard (op6)  op6_r1 := ((r1_val & _h00ff) | (imm << 8)) // 6

	$guard (op7)  op7_r1 := r2_val // 6

        branch_case := (op8 | (op9 | op10)) // 3

        $guard (~branch_case) pc := enpc // 4

	
	$guard (op8)  pc := mem[enpc] // 4
 	
 	$guard (op9)  pc := (enpc + (r1_val + offs)) // 6

	$guard (op10) pc := ( $mux (r1_val == 0) (enpc + offs) enpc) // 6

	$guard (op14) out_port := r1_val // 6

	// WAR dependency from here to reg-reads..
        $guard (updates_r1) new_r_val := ($mux op2 op2_r1 
				          ($mux op3 op3_r1 
					    ($mux op5 op5_r1
					      ($mux op6 op6_r1 
						($mux op7 op7_r1 r1_val))))) // 8

	$guard (updates_r1) reg[r1] := new_r_val 

    $while (halt != 1)
  }
}

