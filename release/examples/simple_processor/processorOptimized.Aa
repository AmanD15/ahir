// Aa code produced by llvm2aa (version 1.0)
$pipe out_port : $uint<16> $depth 1
$storage mem:$array [64] $of $uint<16>

$storage reg:$array [16] $of $uint<16>

$storage pc: $uint<16>

$module [run] 
$in ()
$out ()
$is 
{
  	$branchblock [core] 
  	{
		pc := 0
		$merge $entry loopback
			$phi I := ($bitcast ($uint<4>) 0) $on $entry NI  $on loopback
		$endmerge
		reg[I] := 0 
		NI := (I+1)
		$if (I < 15) $then $place [loopback] $endif

    		$dopipeline $depth 4 $buffering 2
		
    		$merge $entry $loopback 
		$phi halt := ($bitcast($uint<1>) 0) $on $entry nhalt $on $loopback
    		$endmerge
        	
		// stage 1
		ir    := mem[pc] 
		enpc   := (pc + 1) 
	
		// stage 3
  		op := (ir >> 12) // 2
  		r1 := ((ir >> 8) & _h000f) // 2  // get the first register */
  		r2 := ((ir >> 4) & _h000f) // 2  // get the second register */
  		r3 := (ir & _h000f)        // 2  // get the third register */
  		imm := (ir & _h00ff)       // 2 // get the immediate value */
	
		// stage 4
  		offs := (($mux (imm > 127) (128 - imm)  imm) - 1)  //3 // get the offset, and subtract 1 because
                                                  	// the PC has already moved to next location */
	
		// stage 5
		op0 := (op == 0) op1 := (op == 1) op2 := (op == 2) op3 := (op == 3)  
        	op4 := (op == 4) op5 := (op == 5) op6 := (op == 6) op7 := (op ==7)	
        	op8 := (op == 8) op9 := (op == 9) op10 := (op == 10) op14 := (op == 14)	 // 3
	
		nhalt := (op == 0)
        	branch_case := (op8 | (op9 | op10)) 

		// not branch, write to npc
                $guard (~ branch_case)  pc := enpc
	
		// stage 7: register read.
		// write to the read-port pipes... and then read from the result pipes..
		// stage 8: buffering on op1,op2...
		$guard (op1)  reg[r1] := (reg[r2] + reg[r3])   // 6
		$guard (op2)  reg[r1] := (reg[r2] - reg[r3])  // 6
		$guard (op3)  op3_addr  := (reg[r2] + reg[r3]) // 6
        	$guard (op3)  reg[r1] := mem[op3_addr]  // 7
		$guard (op4)  op4_addr := (reg[r2] + reg[r3]) // 6
        	$guard (op4)  mem[op4_addr] := reg[r1] // 7
		$guard (op5)  reg[r1] := ((reg[r1] & _hff00)  | imm) // 6
		$guard (op6)  reg[r1] := ((reg[r1] & _h00ff) | (imm << 8)) // 6
		$guard (op7)  reg[r1] := reg[r2] // 6
		$guard (op14) out_port := reg[r1] // 6
	
		$guard (op8)  pc := mem[enpc] // 4
 		$guard (op9)  pc := (enpc + (reg[r1] + offs)) // 6
		$guard (op10) pc := ( $mux (reg[r1] == 0) (enpc + offs) enpc) // 6

    		$while (halt != 1)
  	}
}
	
