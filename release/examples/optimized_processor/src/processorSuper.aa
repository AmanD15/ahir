$constant Z1 : $uint<1>  := 0
$constant Z4 : $uint<4>  := 0
$constant Z16 : $uint<16> := 0
$constant O1 : $uint<1>  := 1
$constant O16 : $uint<16> := 1

$storage mem_array:$array [64] $of $uint<16>
$storage reg_array:$array [16] $of $uint<16>

$pipe fetch_to_exec : $uint<32> $depth 2 
$pipe exec_to_fetch : $uint<16> $depth 2 
$pipe env_to_processor_start_pc : $uint<16>
$pipe halt_pipe : $uint<8>


// r1 rr1 wr1 r2 rr2 r3 rr3 
// 4  1   1    4  1    4  1 =  16
$pipe reg_read_access_command : $uint<16>

// r1-val r2-val r3-val
//  16     16     16
$pipe reg_read_access_response : $uint<48>


// r1 r1-val
// 4   16
$pipe reg_write_access_command : $uint<20>

// 1-bit
$pipe reg_write_access_response : $uint<1>

$pipeline $module [access_reg_locks]
	$in  (clear_mask test_mask set_mask: $uint<16>)
	$out (locks_available : $uint<1>)
$is
{
	$storage reg_locks: $uint<16>
	
	erlock := reg_locks
	$volatile post_clear_erlock := (erlock & (~ clear_mask))
	locks_available   := ((test_mask & post_clear_erlock) != 0)
	$volatile post_set_erlock   := (post_clear_erlock | set_mask)
	$guard (locks_available) reg_locks := post_set_erlock
}


$pipeline $module [access_regs]
	$in (r1: $uint<4> rr1 wr1: $uint<1> wr1_val: $uint<16> r2: $uint<4> rr2: $uint<1> r3: $uint<4> rr3: $uint<1>)
	$out (r1_val r2_val r3_val: $uint<16>) $is
{
	$guard (wr1) reg_array[r1] := wr1_val
	$guard (rr1) r1_val := reg_array[r1]
	$guard (rr2) r2_val := reg_array[r2]
	$guard (rr3) r3_val := reg_array[r3]
}

$module [reg_read_daemon] 
	$in ()
	$out () $is
{

	$branchblock [lOoP] {
		$dopipeline $depth 8 $buffering 2 $fullrate

			$merge $entry $loopback 
				$phi free_state := O1 $on $entry all_locks_available $on $loopback
			$endmerge

			$guard (free_state) cmd := reg_read_access_command 

			$split (cmd 4 1 1 4 1 4 1)
					(r1 rr1 wr1 r2 rr2 r3 rr3)

			$volatile test_mask 
				:= ($reduce | 
						($mux (wr1 | rr1) (O16 << ($bitcast ($uint<16>) r1)) Z16)
						($mux rr2 (O16 << ($bitcast ($uint<16>) r2)) Z16)
						($mux rr3 (O16 << ($bitcast ($uint<16>) r3)) Z16)
					   )
			$volatile set_mask
				:= ($mux wr1 (O16 << ($bitcast ($uint<16>) r1)) Z16)
			$call access_reg_locks (Z16 test_mask set_mask) (all_locks_available)

			$guard (all_locks_available)
				$call access_regs (r1 rr1 Z1 Z16 r2 rr2 r3 rr3) (r1_val r2_val r3_val)

			$guard (all_locks_available)
					reg_read_access_response := ($concat r1_val r2_val r3_val)

			$while 1

	}
}



$module [reg_write_daemon] 
	$in ()
	$out () $is
{

	$branchblock [lOoP] {
		$dopipeline $depth 8 $buffering 2 $fullrate

			$merge $entry $loopback $endmerge

			cmd := reg_write_access_command 

			$split (cmd 4 16) (r1 r1_val)
			$call access_regs (r1 Z1 O1 r1_val Z4 Z1 Z4 Z1) (i1 i2 i3)
		        reg_write_access_response := O1
			$call access_reg_locks
				((~Z16) (~Z16) (O16 << ($bitcast ($uint<16>) r1))) (all_locks_available)

		$while 1
	}
}


$module [write_to_mem] $in (addr data : $uint<16>) $out () $is
{
	mem_array[addr] := data
}

$pipeline $module [mem_access] 
$in (mem_addr : $uint<16> mem_write_data : $uint<16> mem_read_write_bar: $uint<1>)
$out (mem_read_data: $uint<16>)
$is 
{
	    $guard (~mem_read_write_bar) mem_array[mem_addr] := mem_write_data
	    $guard (mem_read_write_bar)  mem_read_data := mem_array[mem_addr]
}

$volatile $module [decode] $in (instr: $uint<16>) $out (op r1 r2 r3: $uint<4> imm offs: $uint<16>)
$is 
{
   op := ($slice instr 15 12)
   r1 := ($slice instr 11 8) 
   r2 := ($slice instr 7 4) 
   r3 := ($slice instr 3 0)
   imm := (instr & 255)
   offs := ($mux (imm > 127)  (128 - imm) imm)
}



$volatile $module [is_branch] $in (instr: $uint<16>) $out (is_branch_instr: $uint<1>) $is
{
	$volatile op := ($slice instr 15 12)
	$volatile op_8 := (op == 8)
	$volatile op_9 := (op == 9)
	$volatile op_10 := (op == 10)
	is_branch_instr := ($reduce | op_8 op_9 op_10)
}


// keep fetching (one at a time for now)
$module [fetch_daemon] $in () $out () $is
{
  start_pc := env_to_processor_start_pc
  $branchblock [body] 
  {
	$dopipeline $depth 8 $buffering 1 $fullrate 
		$merge $entry $loopback 
			$phi pc := start_pc $on $entry npc $on $loopback
			$phi use_branch_pc := Z1 $on $entry is_branch_instr $on $loopback
		$endmerge 

		$guard (~use_branch_pc) $call mem_access  (pc Z16 O1) (instr)
		$volatile $call is_branch (instr) (is_branch_instr)

		$guard (use_branch_pc)  branch_pc := exec_to_fetch
		$guard (use_branch_pc)  $call mem_access  (branch_pc Z16 01) (instr_b)
		$volatile $call is_branch (instr_b) (is_branch_instr_b)

		$volatile npc := ($mux use_branch_pc (branch_pc + 1) (pc + 1))

		$guard (~use_branch_pc) 
			fetch_to_exec := 	($concat pc instr)
		$guard (use_branch_pc) 
			fetch_to_exec := 	($concat branch_pc instr_b)

	$while 1
  }
}

$module [execute_daemon] $in () $out () $is
{
    $branchblock [lOoP] {

      $dopipeline $depth 16 $buffering 2 $fullrate
	$merge $entry $loopback $endmerge

	iinfo := fetch_to_exec
        $volatile $split (iinfo 16 16) (pc instr)

	$volatile $call decode (instr) (op r1 r2 r3 imm offs)

    	$volatile op_0 := (op == 0)
    	$volatile op_1 := (op == 1)
    	$volatile op_2 := (op == 2)
    	$volatile op_3 := (op == 3)
    	$volatile op_4 := (op == 4)
    	$volatile op_5 := (op == 5)
    	$volatile op_6 := (op == 6)
    	$volatile op_7 := (op == 7)
    	$volatile op_8 := (op == 8)
    	$volatile op_9 := (op == 9)
    	$volatile op_10 := (op == 10)
    	$volatile op_14 := (op == 14)

    	$volatile rr1 := ($reduce | op_4 op_5 op_6 op_9 op_10 op_14) 
    	$volatile rr2 := ($reduce | op_1  op_2  op_3  op_4  op_7)
    	$volatile rr3 := ($reduce | op_1 op_2 op_3 op_4)
	
    	$volatile wr1 := ($reduce | op_1 op_2 op_3  op_5 op_6 op_7)

    	$volatile wr_mem := op_4
    	$volatile rd_mem := ($reduce | op_3 op_8)
	
    	// read-a-reg
        $volatile read_or_lock_reg_flag := ($reduce | rr1 rr2 rr3 wr1)
	$volatile rcmd := ($concat r1 rr1 wr1 r2 rr2 r3 rr3)
	$guard (read_or_lock_reg_flag)
		reg_read_access_command := rcmd
	$guard (read_or_lock_reg_flag) 
		rrsp := reg_read_access_response

	$volatile $split (rrsp 16 16 16) (r1_val r2_val r3_val)

    	$guard (op_3) mem_address_1 := (r2_val + r3_val)
    	$guard (op_8) mem_address_2 := (pc + 1)
    	mem_address := ($excmux (op_3 | op_4) mem_address_1 op_8 mem_address_2)
    	mem_write_data := r1_val
    	amem := (wr_mem | rd_mem)
    	$guard (amem) $call mem_access (mem_address mem_write_data rd_mem) (mem_read_data)
	
    	$guard (op_0) halt_pipe := 1
    	wr1_val := ($excmux 
			op_1   (r2_val + r3_val) 
			op_2   (r2_val - r3_val)
			op_3   mem_read_data 
			op_5   ((r1_val & _b1111111100000000) | imm)
			op_6   ((r1_val & _b0000000011111111) | (imm << 8))
			op_7   r2_val)
	$volatile wcmd := ($concat r1 wr1_val)
	$guard (wr1) reg_write_access_command := wcmd
	$guard (wr1) wrsp := reg_write_access_response


    	npc := ($mux 
		($reduce | op_8 op_9 op_10) 
			($excmux 
				op_8 mem_read_data 
				op_9 ((pc  + offs) + r1_val)
				op_10 ($mux (r1_val == 0) (pc + offs)  (pc + 1)))
			(pc + 1))

	$volatile is_branch_instr := ($reduce | op_8 op_9 op_10)

	$guard (is_branch_instr) exec_to_fetch := npc
    	$guard (op_14) out_port := r1_val
     $while 1
   }
}
