$module [asum]
$in ()
$out ( c : $uint<32>  )
$is
{
  $branchblock [run]
  {
    $do 
    $merge $entry $loopback 
    $phi I := 			  ($bitcast ($uint<32>) 0  ) $on $entry			  NI $on $loopback // type of target is $uint<32>
    $phi R := 			  0  $on $entry			  R4 $on $loopback // type of target is $uint<32>
    $endmerge
    R1 := (R + 1 )
    // target-type =   $uint<32>
    // target-memory-space =  none
    // source-type = $uint<32>
    // source-memory-space =  none
    R2 := (R1 + 1 )
    // target-type =   $uint<32>
    // target-memory-space =  none
    // source-type = $uint<32>
    // source-memory-space =  none
    R3 := (R2 + 1 )
    // target-type =   $uint<32>
    // target-memory-space =  none
    // source-type = $uint<32>
    // source-memory-space =  none
    R4 := (R3 + 1 )
    // target-type =   $uint<32>
    // target-memory-space =  none
    // source-type = $uint<32>
    // source-memory-space =  none
    NI := (I + 1 )
    // target-type =   $uint<32>
    // target-memory-space =  none
    // source-type = $uint<32>
    // source-memory-space =  none
    $while (NI < 10 )
  }
  ( R4 => result )
  c := result
  // target-type =   $uint<32>
  // target-memory-space =  none
  // source-type = $uint<32>
  // source-memory-space =  none
}
$module [ssum]
$in ()
$out ( c : $uint<32>  )
$is
{
  $storage  a : $array[10] $of $uint<32> // memory space index = 0  base address = 0  word size = 32
  // can point into 
  $branchblock [init]
  {
    $do 
    $merge $entry $loopback 
    $phi I := 			  ($bitcast ($uint<32>) 0  ) $on $entry			  NI $on $loopback // type of target is $uint<32>
    $endmerge
    a[I] := I
    // target-type =   $uint<32>
    // target-memory-space =  none
    // source-type = $uint<32>
    // source-memory-space =  none
    NI := (I + 1 )
    // target-type =   $uint<32>
    // target-memory-space =  none
    // source-type = $uint<32>
    // source-memory-space =  none
    $while (NI < 10 )
  }
  $branchblock [run]
  {
    $do 
    $merge $entry $loopback 
    $phi I := 			  ($bitcast ($uint<32>) 0  ) $on $entry			  NI $on $loopback // type of target is $uint<32>
    $phi result := 			  0  $on $entry			  nresult $on $loopback // type of target is $uint<32>
    $endmerge
    nresult := (result + a[I])
    // target-type =   $uint<32>
    // target-memory-space =  none
    // source-type = $uint<32>
    // source-memory-space =  none
    NI := (I + 1 )
    // target-type =   $uint<32>
    // target-memory-space =  none
    // source-type = $uint<32>
    // source-memory-space =  none
    $while (NI < 10 )
  }
  ( result => result )
  c := result
  // target-type =   $uint<32>
  // target-memory-space =  none
  // source-type = $uint<32>
  // source-memory-space =  none
}
// Memory space 0: %ssum:a 
