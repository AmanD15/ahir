<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
   "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- XML file produced from file: AaLRM.tex
     using Hyperlatex v 2.9-in-waiting-rk (oct06) (c) Otfried Cheong
     on Emacs 22.2.1, Thu May 26 16:58:51 2011 -->
<head>
<title>Untitled -- Complete Block Statements</title>

<style type="text/css">
.maketitle { align : center }
div.abstract { margin-left: 20%; margin-right: 10%; }
h3.abstract  { align : center }
div.verse, div.quote, div.quotation {
  margin-left : 10%; 
  margin-right : 10%;
}
dt {font-weight: bold}
</style>
</head>
<body>
<table width="100%" cellpadding="0" cellspacing="2"><tr>
<td bgcolor="#99ccff"><img alt="" src="file:/usr/share/hyperlatex/icons/blank.png"/></td><td bgcolor="#99ccff"><a href="AaLRM_3.html"><img border="0" alt="Statements" src="file:/usr/share/hyperlatex/icons/up.png"/></a></td><td bgcolor="#99ccff"><a href="AaLRM_4.html"><img border="0" alt="Complete Statements" src="file:/usr/share/hyperlatex/icons/previous.png"/></a></td><td align="center" bgcolor="#99ccff" width="100%"><b>Complete Block Statements</b></td></tr></table>
<h2>Complete Block Statements</h2>
<p>Block statements can be used to describe complex
control flows, and consist of a sequence of statements.
Block statements are of
the following types:
</p>
<ul><li><b>Series</b> block statements are of the form
<pre>
series-block-statement :=
             series-block-specifier block-name
             { 
                declarations
                sequence-of-atomic-statements
             }
</pre>
<p>The behaviour is similar to the module, in that the control
token flows serially down the sequence of statements.
Here is an example:
</p>
<pre>
$seriesblock [s1] 
{
   $storage b $uint&lt;32&gt;
   b := a
   b := ( $mux (a &gt; c)  (b+c) (b-c))
   q := ( b * 2)
}
</pre>
<p>In this example, the variable <i>b</i> was declared as
a storage variable in scope s1, and hence was legally
able to be the target of multiple assignment statements.
</li><li><b>Parallel</b> block statements are of the form
<pre>
parallel-block-statement :=
             parallel-block-specifier block-name
             { 
                declarations
                sequence-of-atomic-statements
             }
</pre>
<p>When a token enters the parallel block statement, it
is replicated into as many tokens as there are statements in
the sequence, and all statements are started in parallel.
When all statements have finished and released their token,
the parallel block statement
ends and a single token exits the parallel block statement (this
is essentially a fork followed by a join).
Here is an example
</p>
<pre>
$parallelblock [p1] 
{
   b := a + c
   d := a - c
}
</pre> <p>The two statements will start in parallel, and the block 
will finish when both have finished.  The
order in which the two statements are executed
is <b>not</b> specified.
</li><li><b>Fork</b> block statements are generalizations of the
parallel block region in the sense that they
allow the programmer to express complex fork-join interactions.
They have the following structure:
<pre>
fork-block-statement :=
             fork-block-specifier block-name
             {
                declarations
                sequence-of-statements
             }
</pre>
<p>The control flow is similar to the parallel block region,
in the sense that all statements in the sequence are started
in parallel, and the fork block statement ends when all statements
in the sequence have ended.  The difference is that
fork blocks can have an additional statement which
allows the programmer to provide additional synchronization
points.  These statements are termed <b>join</b> statements
and have the form
</p>
<pre>
join-statement :=
         join-specifier list-of-labels 
          fork-specifier  list-of-statements
</pre>
<p>The meaning of this statement is that it waits until all statements
in the list-of-labels have finished, then starts the list-of-statements
(in parallel) and finishes.  This essentially defines a node in a directed graph,
with the arcs corresponding to statements in the statement-lists.  
The join indicates the arcs (or statements) 
from whom tokens have to arrive.  After all tokens have arrived
on the incoming arcs, tokens are sent along the outgoing arcs specified
in the list of statements following the optional fork specifier.  There is an implicit fork
at the entry point to the fork block statement and an implicit join at the
end of the fork block statement.  It is thus easy to describe
an arbitrary directed graph with arbitrary forks and joins.  The only
restriction is that this directed graph must be acyclic!  This is enforced
by requiring that a join statement refers only to labels of statements
that appear before the join.
Here is an example:
</p>
<pre>
$forkblock [f1] {
  a := (b+c)
  $seriesblock [s1] { ... }
  $seriesblock [s2] { ... }
  $seriesblock [s3] { ... }
  $join s1 s2 $fork 
      $seriesblock [s4] { ... }
  $join s3 s4
}
</pre>
<p>In this example, the first assignment statement as well as s1, s2, s3 are 
started in parallel. When both s1 and s2 have finished, s4 is started and
when s3, s4 have joined and when the first assignment statement has
finished, the forkblock f1 finishes execution.
</li><li><b>Branch</b> block statements are constructs which allow the programmer
to describe arbitrary sequential branching behaviour.  They 
describe a control flow in which a single token 
is active within the block.  The movement of this token is
controlled by special flow control statements.
A branch block is constructed 
as follows
<pre>
branch-block-statement :=
             branch-block-specifier block-name
             { branch-block-statement-sequence }
</pre>
<p>The sequence of statements appearing in a branch block
consist of
</p>
<ul><li>Simple statements or Block statements.
</li><li>Switch statements: A switch statement has
the form
<pre>
switch-statement :=
         switch-spec switch-expression
           ( expr-value  branch-block-statement-sequence )*
           ( default branch-block-statement-sequence )?
         end-switch-spec
</pre>
<p>The switch-expression is checked, and depending on its
value, one of the alternative statements is selected.
Thus, the incoming token to the switch statement is 
passed to one of the alternatives.  For example,
</p>
<pre>
$switch a $when 0 $then a1 := (b + c)
          $when 1 $then a2 := (b - c)
          $default $null
$endswitch
</pre>
<p>The control token is routed to the appropriate
choice sequence and if the token is not routed out 
of the block (by the <b>place</b> statement 
described below), then the token passes to the
statement following the switch. 
</li><li>If statements: An if statement has the form
<pre>
if-statement :=
       if-spec test-expression 
           branch-block-statement-sequence
       (else
           branch-block-statement-sequence)?
       end-if-spec
       
</pre>
<p>For example:
</p>
<pre>
$if (a != 0) $then
   q := (r + s)
   t := 0
$else
   qdash :=  (r - s)
$endif
</pre>
<p>If the control token reaches the end of a selected
segment in the if statement (that is, without being
rerouted by a place statement), then the control
token is passed on to the statement immediately
following the if statement.
</li><li>The place statement: The <b>place</b> statement
identifies a place into which it places
a token after it has executed.  For example,
<pre>
$place [fastpath]
</pre><p>means that the incoming token is placed in a labeled
place <b>fastpath</b> (the place statement never
puts a token into its default exit place).  
The token placed in <b>fastpath</b> must be used to
trigger a unique <b>merge</b> statement which is required
to depend on this labeled place in the same branch
block. If no such merge exists, or if multiple such merges exist, 
then this is an error.
</li><li>Merge statements: A merge statement is
specified as 
<pre>
merge-statement :=
          merge-spec label-list merge-assignments end-merge-spec
</pre>
<p>which is to be interpreted as follows.  The labels in the label list
refer to token labels defined by <b>place</b>  statements within the branch block.
Whenever a token is present in any of the places in
the label-list for a merge,
the merge statement starts and executes a series of special assignments
which multiplex values into new variables based on which arc the
token arrived from.  The merge statement then releases its token to
the next statement. 
</p>
<ul><li>The merge assignments inside a merge block are all of a specific
form, called the phi-statement.  A phi-statement has the following
form
<pre>
$phi a := b $on $entry c $on loopback 
</pre>
<p>This says that the target <i>a</i> is to take the value of <i>b</i> if
the merge statement was started from its entry place (ie from a
token passed from its predecessor) and is to take the value of <i>c</i>
if the merge statement was started from the place "loopback".
Note that if the merge statement is to be triggered by a
token in its default entry place, one of the labels in the
label-list for the merge must contain the identifier &#36;entry.
</p>
</li></ul>
</li></ul>
<p>Here is an example of a branch block constructed in this manner
</p>
<pre>
$branchblock [b1] 
{
  $merge loopback $entry // $entry is the entry place
                         // of the merge statement.
                         // this merge is triggered by
                         // a token entering it from
                         // its predecessor or by  
                         // a token in the place "loop"


       $phi q := 0 on $entry r on loop 
                    // q is defined by where 
                    // the token came from
  $endmerge
  r := (q + 1)
  $if (r &lt; 10) $then 
       $place [loopback] // put token in place "loopback"
  $endif
}
</pre><p>This is to be interpreted as follows: the merge executes
whenever a token is present in its entry place  or in 
the place labeled <b>loopback</b>
The merge defines variable <b>q</b> with a value which is
either 0 (if a token was present in the entry place)
or r (if a token was present in the "loop" place).
By the construction rules in an <b>Aa</b>&nbsp;program, it is
impossible for there to be a token present in more
than one input place to a merge.
</p>
</li></ul>
<p>Thus, an <b>Aa</b>&nbsp;program is constructed as a collection of modules,
each of which is a sequence of statements.  The use of series,
parallel, fork and branch block
statements enables the programmer to describe a highly concurrent
structured system with complex branching behaviour.  
The resulting control flow structure is a
petri-net with provable liveness and safety properties <a href="AaLRM_21.html#ref:SameerPhD">[1]</a>.
</p>
<hr />
<table width="100%" cellpadding="0" cellspacing="2"><tr>
<td bgcolor="#99ccff"><img alt="" src="file:/usr/share/hyperlatex/icons/blank.png"/></td><td bgcolor="#99ccff"><a href="AaLRM_3.html"><img border="0" alt="Statements" src="file:/usr/share/hyperlatex/icons/up.png"/></a></td><td bgcolor="#99ccff"><a href="AaLRM_4.html"><img border="0" alt="Complete Statements" src="file:/usr/share/hyperlatex/icons/previous.png"/></a></td><td align="center" bgcolor="#99ccff" width="100%"><b>Complete Block Statements</b></td></tr></table></body></html>
