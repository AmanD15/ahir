$pipe free_queue_pipe : $uint<32> $depth 20
$pipe in_ctrl : $uint<8> $depth 1
$pipe in_data : $uint<64> $depth 1
$pipe swapped_in_data : $uint<64> $depth 1
$pipe out_ctrl : $uint<8> $depth 1
$pipe out_data : $uint<64> $depth 1
$pipe send_packet_pipe: $uint<32>
$pipe receive_packet_pipe: $pointer<$uint<32> > $depth 2

$pipe send_packet_buf_queue: $uint<32> $depth 4
$pipe receive_packet_buf_queue: $uint<32> $depth 4

// get free buffer slot from free_queue_pipe
$module [ahir_packet_get] $in () $out (buf : $uint<32>)
$is
{
	buf := free_queue_pipe
}


// write free buffer slot to free_queue_pipe
$module [ahir_packet_free] $in (pkt : $uint<32>) $out () $is
{
    free_queue_pipe := (pkt & _b11111111111111111111100000000000)
}


// given the packet, find wlen, blen and buffer pointer
// this was hand optimized by starting with the version
// generated by llvm2aa out of the original wrapper_input
// function.
$module [analyze_packet] $in (pkt: $pointer < $uint<8> >) 
		$out  (buf: $pointer<$uint<8> >  wlen: $uint<16>  blen: $uint<16> )
$is
{
    iNsTr_6 := ($cast ($uint<32>) pkt)
    and := (iNsTr_6 & ( $bitcast ($uint<32> ) _b11111111111111111111100000000000 ) )
    iNsTr_7 := ($cast ($pointer< $uint<8> >) and)
    iNsTr_9 := ($cast ($pointer< $uint<16> >) and)

	// buffer pointer
    buf := iNsTr_7

	// wlen
    addx_xptr := iNsTr_9[( $bitcast ($uint<32> ) _b00000000000000000000000000000001 ) ]
    wlen_h := ->(addx_xptr) 
    iNsTr_11 := ($cast ($pointer< $uint<16> >) buf)
    addx_xptr16 := iNsTr_11[( $bitcast ($uint<32> ) _b00000000000000000000000000000001 ) ]
    wlen_l := ->(addx_xptr16) 
    conv := ($cast ($uint<32>) wlen_l)
    shl := (conv << ( $bitcast ($uint<32> ) _b00000000000000000000000000001000 ) )
    conv21 := ($cast ($uint<32>) wlen_h)
    shr :=  ($bitcast ($uint<32>) ( ($bitcast ( $int<32>) conv21) >>  ($bitcast ( $int<32>) ( $bitcast ($uint<32> ) _b00000000000000000000000000001000 )  )))
    or := (shl | shr)
    wlen := ($cast ($uint<16>) or)

	// blen
    iNsTr_14 := ($cast ($pointer< $uint<16> >) buf)
    addx_xptr25 := iNsTr_14[( $bitcast ($uint<32> ) _b00000000000000000000000000000011 ) ]
    blen_h := ->(addx_xptr25) 
    iNsTr_16 := ($cast ($pointer< $uint<16> >) buf)
    addx_xptr29 := iNsTr_16[( $bitcast ($uint<32> ) _b00000000000000000000000000000011 ) ]
    blen_l := ->(addx_xptr29) 
    conv33 := ($cast ($uint<32>) blen_l)
    shl34 := (conv33 << ( $bitcast ($uint<32> ) _b00000000000000000000000000001000 ) )
    conv36 := ($cast ($uint<32>) blen_h)
    shr37 :=  ($bitcast ($uint<32>) ( ($bitcast ( $int<32>) conv36) >>  ($bitcast ( $int<32>) ( $bitcast ($uint<32> ) _b00000000000000000000000000001000 )  )))
    or38 := (shl34 | shr37)
    blen := ($cast ($uint<16>) or38)
}

// a pipeline: get packet (and analyze), generate pointers, read and send.
$module [send_packet_pipeline] $in () $out ()
$is
{
	$pipe buf64_pipe: $pointer<$uint<64> > $depth 2
	$pipe pkt64_pipe: $pointer<$uint<64> > $depth 2
	$pipe wlen_pipe: $uint<16> $depth 2
	$pipe blen_pipe: $uint<16> $depth 2

	$pipe read_ctrl_in : $uint<8> $depth 2
	$pipe read_pointer : $pointer<$uint<64> > $depth 2
	$pipe read_last_word_in : $uint<1> $depth 2

	$pipe swap_ctrl_in : $uint<8> $depth 2
	$pipe swap_data_in : $uint<64> $depth 2
	$pipe swap_last_word_in : $uint<1> $depth 2


	$parallelblock[Pipeline] {

		$branchblock[GetPkt] {
			$merge $entry loopback $endmerge

			pkt := send_packet_pipe
			$call analyze_packet(($bitcast ($pointer<$uint<8> >) pkt)) (buf wlen blen)
			$parallelblock[WritePipe] {
				buf64_pipe := ($bitcast ( $pointer < $uint<64> >) buf)
				pkt64_pipe := ($bitcast ( $pointer < $uint<64> >) pkt)
				wlen_pipe := wlen
				blen_pipe := blen
				send_packet_buf_queue := ($bitcast ($uint<32>) pkt)
			}
			$place [loopback]
		}
		$branchblock[SeqPkt] {
			$merge $entry loopback $endmerge
			$parallelblock[ReadPipes] {
				wlen := wlen_pipe
				blen := blen_pipe
				buf64 := buf64_pipe
				pkt64 := pkt64_pipe
			} ( wlen => wlen blen => blen buf64 => buf64 pkt64 => pkt64)
			$if (wlen > 0) $then
				$parallelblock[Hdr] {
					read_ctrl_in := _b11111111
					read_pointer := buf64
					read_last_word_in := 0
					LI := (wlen-1)
				} (LI => LI)

				$merge $entry InteriorLoop
					$phi I := ($bitcast ($uint<16>) _b0) $on $entry NI $on InteriorLoop
				$endmerge
			
				$parallelblock[Body] {
					read_ctrl_in := _b00000000
		        		read_pointer := pkt64[I]
					read_last_word_in := 0
					NI := (I+1)
				} (NI => NI)

				$if (NI < LI) $then
					$place [InteriorLoop]
				$endif

		        	last_word_ptr := pkt64[LI]

				$parallelblock[LastWord] {
					read_ctrl_in := (($bitcast ($uint<8>) 1) << 
						($bitcast($uint<8>) ((8 - (blen & 7)) & 7)))
					read_pointer := last_word_ptr
					read_last_word_in := 1
	
				}
			$endif
			$place [loopback]
		}
                $branchblock[ReadWord] {
			$merge $entry loopback $endmerge
			
			ptr := read_pointer

			$parallelblock[pipes] {
				swap_data_in := ->(ptr)
				swap_ctrl_in := read_ctrl_in
				swap_last_word_in := read_last_word_in
			}

			$place [loopback]
                }
		$branchblock[SwapAndSend] {
			$merge $entry loopback $endmerge
                        a := swap_data_in
			$parallelblock[Send] {
				out_data := 
					(((($bitcast($uint<8>) a) && ($bitcast($uint<8>) (a >> _b1000))) &&
                 			(($bitcast($uint<8>) (a >> _b10000)) && ($bitcast($uint<8>) (a >> _b11000)))) &&
                 			((($bitcast($uint<8>) (a >> _b100000)) && ($bitcast($uint<8>) (a >> _b101000))) &&
                 			(($bitcast($uint<8>) (a >> _b110000)) && ($bitcast($uint<8>) (a >> _b111000)))))
				out_ctrl := swap_ctrl_in
			}

			$if (swap_last_word_in != 0) $then
				$call ahir_packet_free (send_packet_buf_queue) ()
			$endif
			$place [loopback]
		}
	}
}


//
// a free running four stage pipeline, which stores
// incoming packet data..
//
$module [receive_packet_pipeline] $in () $out ()
$is
{
   $pipe buf8_ptr_pipe : $pointer<$uint<8> >  $depth 2
   $pipe buf64_ptr_pipe : $pointer<$uint<64> >  $depth 2
   $pipe pkt8_ptr_pipe : $pointer<$uint<8> >  $depth 2
   $pipe pkt64_ptr_pipe : $pointer<$uint<64> >  $depth 2

   $pipe write_data   : $uint<64>  $depth 2
   $pipe write_data_wptr : $pointer<$uint<64> >  $depth 2
   $pipe write_data_last_word_flag : $uint<1> $depth 2


   $parallelblock[Pipeline] {
	// keep swapping in_data bytes and forward on swapped_in_data
       $branchblock[SwapInData]
       {
		$merge $entry loopback $endmerge
		a := in_data
        	swapped_in_data :=  
			(((($bitcast($uint<8>) a) && ($bitcast($uint<8>) (a >> _b1000))) &&
                 	(($bitcast($uint<8>) (a >> _b10000)) && ($bitcast($uint<8>) (a >> _b11000)))) &&
                 	((($bitcast($uint<8>) (a >> _b100000)) && ($bitcast($uint<8>) (a >> _b101000))) &&
                 	(($bitcast($uint<8>) (a >> _b110000)) && ($bitcast($uint<8>) (a >> _b111000)))))
		$place [loopback]
        }

	// wait to get a free buffer and forward to ReceiveWords..
	$branchblock[ReceiveBuffer] {
		$merge $entry loopback $endmerge
		$call ahir_packet_get () (buf)
		buf8_ptr := ($bitcast ($pointer <$uint<8> >) buf)
		buf64_ptr := ($bitcast ($pointer <$uint<64> >) buf)
	        pkt8_ptr := buf8_ptr[180]
		receive_packet_buf_queue := buf
		$parallelblock[Pointers] {
			buf8_ptr_pipe := buf8_ptr
			buf64_ptr_pipe := buf64_ptr
			pkt8_ptr_pipe := pkt8_ptr
			pkt64_ptr_pipe :=  ($bitcast ($pointer <$uint<64> >) pkt8_ptr)
		}

		$place [loopback]
	} 


	// receive words from swapped_in_data (an entire packet is
	// collected).
	$branchblock[ReceiveWords] {
		
		$merge $entry loopback $endmerge

		$parallelblock[Pointers] {
			buf8_ptr := buf8_ptr_pipe
			buf64_ptr := buf64_ptr_pipe
	
			pkt8_ptr := pkt8_ptr_pipe 
			pkt64_ptr := pkt64_ptr_pipe 
		} (buf8_ptr => buf8_ptr buf64_ptr => buf64_ptr pkt8_ptr => pkt8_ptr pkt64_ptr => pkt64_ptr)

		$merge $entry BadPacket $endmerge

		$parallelblock[HeaderRead] {
			hdr_in_data := swapped_in_data
			hdr_in_ctrl := in_ctrl
		} (hdr_in_ctrl => hdr_in_ctrl hdr_in_data => hdr_in_data)

		$if (hdr_in_ctrl != _b11111111) $then
			$place [BadPacket]
		$endif
	
		$parallelblock[ToWrite] {
			write_data := hdr_in_data
			write_data_last_word_flag := 0
			write_data_wptr := buf64_ptr
		}

		$merge $entry PktLoop 
			$phi I := ($bitcast ($uint<8>) _b0) $on $entry NI $on PktLoop
		$endmerge

		$parallelblock[BodyRead] {
			pkt_in_data := swapped_in_data
			pkt_in_ctrl := in_ctrl
			NI := (I+1)
		} (pkt_in_ctrl => pkt_in_ctrl pkt_in_data => pkt_in_data NI => NI)

	
		$parallelblock[ToWrite2] {
			write_data := pkt_in_data
			write_data_wptr := pkt64_ptr[I]
			write_data_last_word_flag := ($mux (pkt_in_ctrl == 0) 0 1)
		} 


		$if (pkt_in_ctrl == _b0) $then
			$place [PktLoop]
		$endif
	
		$place [loopback]
    	}

	$branchblock[WriteWords] {
		$merge $entry loopback $endmerge
		->(write_data_wptr) := write_data
		$if (write_data_last_word_flag != 0) $then
			receive_packet_pipe := ($bitcast ($pointer<$uint<32> >) receive_packet_buf_queue)
		$endif
		$place [loopback]
	}
    } 

}



