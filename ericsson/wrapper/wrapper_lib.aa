$pipe free_queue_pipe : $uint<32> $depth 16
$pipe in_ctrl : $uint<8> $depth 1
$pipe in_data : $uint<64> $depth 1
$pipe out_ctrl : $uint<8> $depth 1
$pipe out_data : $uint<64> $depth 1

// get free buffer slot from free_queue_pipe
$module [ahir_packet_get] $in () $out (buf : $uint<32>)
$is
{
	buf := free_queue_pipe
}


// write free buffer slot to free_queue_pipe
$module [ahir_packet_free] $in (pkt : $uint<32>) $out () $is
{
    free_queue_pipe := (pkt & _b11111111111111111111100000000000)
}


// given the packet, find wlen, blen and buffer pointer
// this was hand optimized by starting with the version
// generated by llvm2aa out of the original wrapper_input
// function.
$module [analyze_packet] $in (pkt: $pointer < $uint<8> >) 
		$out  (buf: $pointer<$uint<8> >  wlen: $uint<16>  blen: $uint<16> )
$is
{
    iNsTr_6 := ($cast ($uint<32>) pkt)
    and := (iNsTr_6 & ( $bitcast ($uint<32> ) _b11111111111111111111100000000000 ) )
    iNsTr_7 := ($cast ($pointer< $uint<8> >) and)
    iNsTr_9 := ($cast ($pointer< $uint<16> >) and)

	// buffer pointer
    buf := iNsTr_7

	// wlen
    addx_xptr := iNsTr_9[( $bitcast ($uint<32> ) _b00000000000000000000000000000001 ) ]
    wlen_h := ->(addx_xptr) 
    iNsTr_11 := ($cast ($pointer< $uint<16> >) buf)
    addx_xptr16 := iNsTr_11[( $bitcast ($uint<32> ) _b00000000000000000000000000000001 ) ]
    wlen_l := ->(addx_xptr16) 
    conv := ($cast ($uint<32>) wlen_l)
    shl := (conv << ( $bitcast ($uint<32> ) _b00000000000000000000000000001000 ) )
    conv21 := ($cast ($uint<32>) wlen_h)
    shr :=  ($bitcast ($uint<32>) ( ($bitcast ( $int<32>) conv21) >>  ($bitcast ( $int<32>) ( $bitcast ($uint<32> ) _b00000000000000000000000000001000 )  )))
    or := (shl | shr)
    wlen := ($cast ($uint<16>) or)

	// blen
    iNsTr_14 := ($cast ($pointer< $uint<16> >) buf)
    addx_xptr25 := iNsTr_14[( $bitcast ($uint<32> ) _b00000000000000000000000000000011 ) ]
    blen_h := ->(addx_xptr25) 
    iNsTr_16 := ($cast ($pointer< $uint<16> >) buf)
    addx_xptr29 := iNsTr_16[( $bitcast ($uint<32> ) _b00000000000000000000000000000011 ) ]
    blen_l := ->(addx_xptr29) 
    conv33 := ($cast ($uint<32>) blen_l)
    shl34 := (conv33 << ( $bitcast ($uint<32> ) _b00000000000000000000000000001000 ) )
    conv36 := ($cast ($uint<32>) blen_h)
    shr37 :=  ($bitcast ($uint<32>) ( ($bitcast ( $int<32>) conv36) >>  ($bitcast ( $int<32>) ( $bitcast ($uint<32> ) _b00000000000000000000000000001000 )  )))
    or38 := (shl34 | shr37)
    blen := ($cast ($uint<16>) or38)
}

// first get wlen, blen out of the packet,
// then send out the packet to out_ctrl/out_data
$module [send_packet] $in (pkt: $uint<32>) $out ()
$is
{
	$call analyze_packet(($bitcast ($pointer<$uint<8> >) pkt)) (buf wlen blen)

	buf64 := ($bitcast ( $pointer < $uint<64> >) buf)
	pkt64 := ($bitcast ( $pointer < $uint<64> >) pkt)
	$branchblock[main] {
		$if (wlen > 0) $then
			hdr_word := ->(buf64)
			$call swap_bytes64 (hdr_word)  (hdr_word_swapped)
			$parallelblock[Hdr] {
				out_ctrl := _b11111111
				out_data := hdr_word_swapped
				LI := (wlen-1)
			} (LI => LI)

			$merge $entry InteriorLoop
				$phi I := ($bitcast ($uint<16>) _b0) $on $entry NI $on InteriorLoop
			$endmerge
			
		        word_ptr := pkt64[I]
			curr_word := ->(word_ptr)
			$call swap_bytes64 (curr_word) (curr_word_swapped)

			$parallelblock[Hdr] {
				out_ctrl := _b00000000
				out_data := curr_word_swapped
				NI := (I+1)
			} (NI => NI)

			$if (NI < LI) $then
				$place [InteriorLoop]
			$endif

		        last_word_ptr := pkt64[LI]
			last_word := ->(last_word_ptr)
			$call swap_bytes64 (last_word) (last_word_swapped)

			$parallelblock[LastWord] {
				out_ctrl := (($bitcast ($uint<8>) 1) << 
						($bitcast($uint<8>) ((8 - (blen & 7)) & 7)))
				out_data := last_word_swapped

			}
		$endif
	}
}


//
// given buffer, receive packet from in_ctrl/in_data.
//
$module [receive_packet] $in (buf: $uint<32>) $out ()
$is
{
   $branchblock[main]
   {
	buf8_ptr := ($bitcast ($pointer <$uint<8> >) buf)
	buf64_ptr := ($bitcast ($pointer <$uint<64> >) buf)

	pkt8_ptr := buf8_ptr[180]
	pkt64_ptr :=  ($bitcast ($pointer <$uint<64> >) pkt8_ptr)

	$merge $entry BadPacket $endmerge

	$parallelblock[HeaderRead] {
		hdr_in_data := in_data
		hdr_in_ctrl := in_ctrl
	} (hdr_in_ctrl => hdr_in_ctrl hdr_in_data => hdr_in_data)

	$if (hdr_in_ctrl != _b11111111) $then
		$place [BadPacket]
	$endif
	
	$call swap_bytes64 (hdr_in_data) (hdr_in_data_swapped)

	->(buf64_ptr) := hdr_in_data_swapped

	$merge $entry PktLoop 
		$phi I := ($bitcast ($uint<8>) _b0) $on $entry NI $on PktLoop
	$endmerge

	$parallelblock[HeaderRead] {
		pkt_in_data := in_data
		pkt_in_ctrl := in_ctrl
		NI := (I+1)
	} (pkt_in_ctrl => pkt_in_ctrl pkt_in_data => pkt_in_data NI => NI)

	
	$parallelblock[Wptr] {
		$call swap_bytes64 (pkt_in_data) (pkt_in_data_swapped)
		wptr := pkt64_ptr[I]
	} (wptr => wptr pkt_in_data_swapped => pkt_in_data_swapped)

	->(wptr) := pkt_in_data_swapped

	$if (pkt_in_ctrl == _b0) $then
		$place [PktLoop]
	$endif
	
    }
}



// swap bytes.. 
$module [swap_bytes64]
$in (a: $uint<64>) $out (ret: $uint<64>) $is
{
        ret :=  (((($bitcast($uint<8>) a) && ($bitcast($uint<8>) (a >> _b1000))) &&
                 (($bitcast($uint<8>) (a >> _b10000)) && ($bitcast($uint<8>) (a >> _b11000)))) &&
                 ((($bitcast($uint<8>) (a >> _b100000)) && ($bitcast($uint<8>) (a >> _b101000))) &&
                 (($bitcast($uint<8>) (a >> _b110000)) && ($bitcast($uint<8>) (a >> _b111000)))))
}

