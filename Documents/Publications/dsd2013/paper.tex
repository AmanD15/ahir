\documentclass[conference]{IEEEtran} 
\usepackage{graphicx}
\usepackage[tight,footnotesize]{subfigure}
\usepackage{amsmath}
\usepackage{alltt}
\usepackage{multirow}
\usepackage{times}
\usepackage{url}

\title{On the efficient implementation of loops in hardware}

\author{Madhav P. Desai\\
  Indian Institute of Technology -- Bombay, Powai, Mumbai -- 400076, INDIA\\
  Email: madhav@ee.iitb.ac.in }
\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]

\newcommand{\sym}[1]{$\operatorname{#1}$}

\newbox\subfigbox             % Create a box to hold the subfigure.
\makeatletter
  \newenvironment{subfloat}% % Create the new environment.
    {\def\caption##1{\gdef\subcapsave{\relax##1}}%
     \let\subcapsave=\@empty % Save the subcaption text.
     \let\sf@oldlabel=\label
     \def\label##1{\xdef\sublabsave{\noexpand\label{##1}}}%
     \let\sublabsave\relax    % Save the label key.
     \setbox\subfigbox\hbox
       \bgroup}%              % Open the box...
      {\egroup                % ... close the box and call \subfigure.
     \let\label=\sf@oldlabel
     \subfigure[\subcapsave]{\box\subfigbox\sublabsave}}%
\makeatother

\pagestyle{empty}

\begin{document}

\maketitle
\thispagestyle{empty}

\begin{abstract}

  In the context of mapping high-level algorithms to hardware,
  we consider the basic problem of generating an efficient hardware 
  implementation of a loop.  We describe a control-flow mechanism through
  which multiple iterations of a loop can be dynamically pipelined in
  the generated hardware,  and study the extent to which this 
  mechanism affects the properties of the generated hardware.
  First, we observe that the additional resources needed by this
  mechanism are small.  Further, we observe that this mechanism, when
  combined with static loop unrolling, offers an order-of-magnitude improvement 
  in performance for common linear-algebra kernels such as matrix multiplication 
  and inner product computations.  Finally, we observe that static
  loop unrolling together with dynamic loop pipelining can give us
  efficient hardware with excellent utilization of the available arithmetic
  resources in the circuit.

\end{abstract}

\section{Introduction}


%% The importance and problem of loops.

%% How compilers have handled this problem.

%% Algorithm-to-hardware:  can similar techniques work?

\section{Related work}

%% compiler techniques.

%% hls techniques to handle loops?


\section{Model of hardware generated by our compiler}

%%
%%  control path and data-flow
%%

\subsection{Control-path}

%% 
%% Petri-net, constructed according to
%% certain rules.  Req/Ack transitions
%%

\subsection{Data-path}

%%
%% Directed hyper-graph.  Nodes are operators
%% hyper-arcs are wires.  Each operator node
%% has a split protocol.
%%

\subsection{Memory-subsystem}

%%
%% time-stamping scheme, in order completion.
%%

\subsection{An example of a loop}

%%
%% for(i=0;i < 100; i++)
%% {
%%    c[i] = a[i] + b[i];
%% }
%%

\section{Control-flow mechanism for loop-pipelining}

%%
%% reenable rules.
%%
%% loop-terminator.
%%
%% advantages of dynamic pipelining: any loop
%% can be handled..
%%

\section{Experimental Results}

%%
%% examples: vector add, dot-product, matrix-multiply, linfinity-norm.
%%
%%
%%       show results without-unrolling-pipelining, with-unrolling-pipelining, etc.
%%

\section{Conclusion}

%%
%% loop-pipelining and loop-unrolling have high impact as
%% in pipelined processors.
%%
%% hardware mechanism for loop-pipelining is cheap and effective.
%%
%% can get 10X improvement and very high utilization of 
%% hardware resources.
%%

\bibliography{ref}
\bibliographystyle{IEEEtran}

\end{document}

% LocalWords:  Req Ack LL DP CP cmpgt br cdfg cp dp ir intra req init NCA SA mW
% LocalWords:  TPR STPR STPRs ccccc RTL ASIC petri ack versa liveness LRG LLVM
% LocalWords:  VHDL SRAM Synopsys AES LPK Linpack FFT RBT Synposys OSU TSMC nJ
% LocalWords:  nm
