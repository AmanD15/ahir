\documentclass{article}

\title{Aa Language Reference Manual}
\author{Madhav Desai \\ Department of Electrical Engineering \\ Indian Institute of Technology \\
	Mumbai 400076 India}

\newcommand{\Aa}{{\bf Aa}~}

\begin{document}
\maketitle

\section{Introduction}

{\bf Aa} is intended to be a low-level 
programming language for the description
of algorithms in which the control flow
can be modeled by a petri net
of a specific class (the type-2 petri-net as
introduced in \cite{ref:SameerPhD}).  A program in
\Aa can also be viewed as a 
description of a system which reacts with 
its environment through input and output ports and 
through message queues.  Thus, an \Aa program
can be directly executed on a computer, and
can also be mapped to a logic circuit.

In the rest of this document, we outline the
structure and the syntax of the \Aa language,
and also describe the semantics of an \Aa
program, especially the execution model and
the behaviour of the equivalent system.


\section{Program structure}


A program in \Aa consists of a sequence of
declarations and module definitions.  
\begin{verbatim}
program := ( module-definition | program-object-declaration )*
\end{verbatim}
Declarations at the program level 
can belong to one of three classes:
\begin{itemize}
\item {\bf Storage} objects declared in the program
are globally visible variables that can be read from
anywhere in the program and can be written from anywhere
in the program.
\item {\bf Pipe} objects declared in the program are
globally visible first-in-first-out queues that can 
be read from anywhere in the program. 
written into by at most one module in the program.
\begin{itemize}
\item A pipe can be written into by at most one module
in the program, and can be read from by at most one module
in the program.
\item A pipe that is only written into in the program, but
is not read from, is assumed to have a destination outside
the program.
\item A pipe that is only read from in a program but not
written into, is assumed to have a source outside the program.
\end{itemize}
\item {\bf Constant} objects are globally visible and have
initial values which can never be altered in the program.
Thus, an assignment to a constant is an error.
\end{itemize} 

A module in \Aa is the basic unit of compilation, and
has the following structure
\begin{verbatim}
module-definition :=  
                 module-specifier module-name  
                 module-input-arguments
                 module-output-arguments
                 module-object-declarations
                 { <module-body> }
\end{verbatim}
Thus, a module has a name, has input and output arguments,
declares objects and consists of a sequence of statements.
Objects (storage/pipe/constant) declared in the module are visible only in the
module body. 

The module body itself is a sequence of statements.
\begin{verbatim}
module-body := (statement)+
\end{verbatim}
Each statement can be viewed as a transition
in a petri-net, and has a 
set of input (or source) places  and a set of output
(or sink)  places.  
The execution of the statement is triggered when
there is a token present in each of its source 
places and when the statement finishes execution,
a token is placed in each of its output places.
The control flow in the sequence of statements
in a module is serial in nature.  Thus each
statement has a single source place and a single
sink place, sink place of a statement being 
the source place of its successor.
The module as a whole can be viewed as having
a single entry place and a single exit place.
When a token appears in the entry place, the first
statement can trigger, and when the last statement
has finished, a token is placed in the exit
place.  

The region between \{ and \} is termed a {\bf scope}.  Thus, 
the module description defines a scope.  In this case, 
the scope has a label which is the same as the module name.
As we shall see later, the statements in the statement sequence
may in turn define scopes, which may be labeled or anonymous.
Each scope defines a name-space.  The visibility
rules and access mechanisms between scopes will be described
in Section \ref{sec:Scopes}


\section{Statements}
 
Statements in the module-body are can be of two kinds:
\begin{itemize}
\item Atomic statements: those that have a single
entry place and a single exit place.  These are
the only statements that can occur in a module body.
These statements are further divided into 
{\em simple} statements and {\em block} statements.
\item Sub-atomic statements:  these statements
can appear only inside block statements,  and they
can have multiple sources and multiple sinks.
Examples of these statements are statements for
combining tokens (merge and join statements) and
statements for redirecting tokens (the toss statement).
\end{itemize}


\subsection{Simple Statements}

Simple statements can be one of the following:
\begin{itemize}
\item An {\bf assignment} statement is of the form
\begin{verbatim}
target-ref := expression
\end{verbatim}
where {\em target-ref} either specifies a declared object
or an undeclared name.  If it is an undeclared name, then
it is an implicit variable that is attached to the
assignment statement.  No other statement can write to this
variable, but any statement can read from this variable
subject to scoping rules.  Thus, every implicit variable
is such that exactly one statement defines its value.
When control flow reaches an assignment statement, it
evaluates the expression, updates the value of the target
and passes the control flow forward (we will see what this
means in the sequel).
Some examples of simple statements are 
\begin{verbatim}
a  :=  ($not b)
b  :=   (c + (d + e))
\end{verbatim}
etc.  
More details of the syntax are provided in 
Section \ref{sec:Syntax}.
\item A {\bf call} statement is of the form
\begin{verbatim}
call-spec module-name input-argument-values output-argument-targets
\end{verbatim}
The call statement thus specifies a module to which control flow
is to be passed.  The call statement may itself define new implicit
variables through its specified targets (and thus is the only
statement that can modify these newly defined implicit variables).
When control flow reaches the call statement, it forwards the
token to the called module, and finishes when the token exits
the called module.  Recursive calls and cyclical dependencies between
modules through call statements are not permitted in the \Aa language.
Here is an example of a call statement
\begin{verbatim}
// pass control to a module named foo
// foo has two inputs and three outputs
$call foo (p,q)  (r,s,t)
\end{verbatim}
More details of the syntax are provided in 
Section \ref{sec:Syntax}.
\item The {\bf null} statement does nothing, and just passes the
token onwards.  This is how it looks like
\begin{verbatim}
$null
\end{verbatim}
\end{itemize}

\subsection{Block Statements}

Block statements can be used to describe complex
control flows, and consist of a sequence of statements.
Block statements are of
the following types:
\begin{itemize}
\item {\bf Series} block statements are of the form
\begin{verbatim}
series-block-statement :=
             series-block-specifier block-name
             { 
                declarations
                sequence-of-atomic-statements
             }
\end{verbatim}
The behaviour is similar to the module, in that the control
token flows serially down the sequence of statements.
Here is an example:
\begin{verbatim}
$seriesblock [s1] 
{
   $declare $storage b $uint<32>
   b := a
   b := ( $mux (a > c)  (b+c) (b-c))
   q := ( b * 2)
}
\end{verbatim}
In this example, the variable $b$ was declared as
a storage variable in scope s1, and hence was legally
able to be the target of multiple assignment statements.
\item {\bf Parallel} block statements are of the form
\begin{verbatim}
parallel-block-statement :=
             parallel-block-specifier block-name
             { 
                declarations
                sequence-of-atomic-statements
             }
\end{verbatim}
When a token enters the parallel block statement, it
is replicated into as many tokens as there are statements in
the sequence, and all statements are started in parallel.
When all statements have finished and released their token,
the parallel block statement
ends and a single token exits the parallel block statement (this
is essentially a fork followed by a join).
Here is an example
\begin{verbatim}
$parallelblock [p1] 
{
   b := a + c
   d := a - c
}
\end{verbatim}
The two statements will start in parallel, and the block 
will finish when both have finished.  The
order in which the two statements are executed
is {\bf not} specified.
\item {\bf Fork} block statements are generalizations of the
parallel block region in the sense that they
allow the programmer to express complex fork-join interactions.
They have the following structure:
\begin{verbatim}
fork-block-statement :=
             fork-block-specifier block-name
             {
                declarations
                sequence-of-statements
             }
\end{verbatim}
The control flow is similar to the parallel block region,
in the sense that all statements in the sequence are started
in parallel, and the fork block statement ends when all statements
in the sequence have ended.  The difference is that
fork blocks can have an additional statement which
allows the programmer to provide additional synchronization
points.  These statements are termed {\bf join} statements
and have the form
\begin{verbatim}
join-statement :=
         join-specifier list-of-labels 
          fork-specifier  list-of-statements
\end{verbatim}
The meaning of this statement is that it waits until all statements
in the list-of-labels have finished, then starts the list-of-statements
(in parallel) and finishes.  This essentially defines a node in a directed graph,
with the arcs corresponding to statements in the statement-lists.  
The join indicates the arcs (or statements) 
from whom tokens have to arrive.  When all tokens have arrived
on the incoming arcs, tokens are sent along the outgoing arcs specified
in the list of statements following the optional fork specifier.  There is an implicit fork
at the entry point to the fork block statement and an implicit join at the
end of the fork block statement.  It is thus easy to describe
an arbitrary directed graph with arbitrary forks and joins.  The only
restriction is that this directed graph must be acyclic!  This is enforced
by requiring that a join statement refers only to labels of statements
that appear before the join.
Here is an example:
\begin{verbatim}
$forkblock [f1] {
  a := (b+c)
  $seriesblock [s1] { ... }
  $seriesblock [s2] { ... }
  $seriesblock [s3] { ... }
  $join s1 s2 $and $fork 
      $seriesblock [s4] { ... }
  $join s3 s4
}
\end{verbatim}
In this example, the first assignment statement as well as s1, s2, s3 are 
started in parallel. When both s1 and s2 have finished, s4 is started and
when s3, s4 have joined and when the first assignment statement has
finished, the forkblock f1 finishes execution.
\item {\bf Branch} block statements are constructs which allow the programmer
to describe arbitrary sequential branching behaviour.  They 
describe a control flow in which a single token 
is active within the block.  The movement of this token is
controlled by special flow control statements.
They are structured 
as follows
\begin{verbatim}
branch-block-statement :=
             branch-block-specifier block-name
             { sequence-of-statements}
\end{verbatim}
The sequence of statements appearing in a branch block
consist of
\begin{itemize}
\item Simple statements or Block statements.
\item Switch statements: A switch statement has
the form
\begin{verbatim}
switch-statement :=
         switch-spec switch-expression
           ( expr-value  serial-statement-sequence )*
           ( default serial-statement-sequence )?
            
\end{verbatim}
The switch-expression is checked, and depending on its
value, one of the alternative statements is selected.
Thus, the incoming token to the switch statement is 
passed to one of the alternatives.  For example,
\begin{verbatim}
$switch a $when 0 $then a1 := (b + c)
          $when 1 $then a2 := (b - c)
          $default $null
$endswitch
\end{verbatim}
The control token is routed to the appropriate
choice sequence and if the token is not routed out 
of the block (by the {\bf place} statement 
described below), then the token passes to the
statement following the switch. 
\item If statements: An if statement has the form
\begin{verbatim}
if-statement :=
       if-spec test-expression 
           serial-statement-sequence
       (else
           serial-statement-sequence)?
       
\end{verbatim}
For example:
\begin{verbatim}
$if (a != 0) $then
   q := (r + s)
   t := 0
$else
   qdash :  (r - s)
$endif
\end{verbatim}
If the control token reaches the end of a selected
segment in the if statement (that is, without being
rerouted by a place statement), then the control
token is passed on to the statement immediately
following the if statement.
\item The place statement: The {\bf place} statement
defines a place with a label  into which it places
a token after it has executed.  For example,
\begin{verbatim}
$place [fastpath]
\end{verbatim}
means that the incoming token is placed in a labeled
place ``fastpath''.  The token will either
trigger a {\bf merge} statement which is required
to depend on this labeled place in the same branch
block, or if no such merge statement
exists, then ``fastpath'' is identified
with the exit place of the  containing branch block.
\item Merge statements: A merge statement is
specified as 
\begin{verbatim}
merge-statement :=
          merge-spec label-list merge-assignments
\end{verbatim}
which is to be interpreted as follows.  The labels in the label list
refer to token labels defined by ``toss'' statements within the branch block.
Whenever a token labeled by any of the items in label-list arrives
at the input of the merge,
the merge statement starts and executes a series of special assignments
which multiplex values into new variables based on which arc the
token arrived from.  The merge statement then releases its token to
the next statement. 
\end{itemize}

Here is an example of a branch block constructed in this manner
\begin{verbatim}
$branchblock [b1] 
{
  $merge loop $entry // $entry is the place
                     // into the block
                     // merge triggered by
                     // token at entry or
                     // by token in place "loop"


       $phi q := 0 on $entry r on loop 
                    // q is defined by where 
                    // the token came from
  r := q + 1
  $if r < 10 $then 
       $place [loop] // put token in place "loop"
  $endif
}
\end{verbatim}
This is to be interpreted as follows: the merge executes
whenever a token is present  either in the entry place
of the branch-block or in the place labeled ``loop''.
The merge defines variable ``q'' with a value which is
either 0 (if a token was present in the entry place)
or r (if a token was present in the ``loop'' place).
By the construction rules in an \Aa program, it is
impossible for there to be a token present in more
than one input place to a merge.
\end{itemize}

Thus, an \Aa program is constructed as a collection of modules,
each of which is a sequence of statements.  The use of series,
parallel, fork and branch block
statements enables the programmer to describe a highly concurrent
structured system with complex branching behaviour.  
The resulting control flow structure is a
type-2 petri-net with provable liveness and safety properties \cite{ref:SameerPhD}.

\section{Scoping Rules} \label{sec:Scopes}

An \Aa program is made of modules which in turn contain statements
and so on.  The program thus has a hierarchy of scopes with each
scope being contained in another (except for the program itself,
which is not contained in any scope).

The rules for scoping are as follows:
\begin{enumerate}
\item A variable (declared or implicit) defined in a scope is visible
in all descendant scopes.
\item A reference to a variable $b$ in a scope X is resolved by checking
whether the variable is defined in that scope, and if not found there,
by checking in the scope that contains the scope X, and so on.
\item A scope can read from variables that are defined in descendant
scopes.  
\item A scope can read from variables that are defined in ancestor scopes.
\end{enumerate}

A variable which is to be read in a statement may be specified 
as follows
\begin{verbatim}
a            look for variable a in current scope; 
             if not found look in the parent.

:a           same as the previous case

^:a          look for variable a defined in the parent of
             the current scope.

%p:a         look for variable a defined in the child scope 
	     with label p (child scope of the current scope).

^^:a         look for variable a defined in the parent of
             the parent of the current scope.

%p%q:a       look for variable a defined in the child scope 
             with label q of the child scope with label p of 
             the current scope

a[10]        look for a storage variable a defined in the 
             current module.  If not found, look for it in
             the program scope.  If found in either of the places,
             access the corresponding element of the array.
\end{verbatim}
Thus, a generic variable reference has the form 
\begin{verbatim} 
    scope-id : variable-reference 
\end{verbatim} 
and the scoping rules forbid a scope from accessing variables
which are not defined in either an ancestor or a descendant
of the scope.

\section{Examples}

Here is a very simple program
\begin{verbatim}
// an array of 32-bit unsigned integers.
$storage mem $array<1024> of $uint<32> 
$module [sel_mod]
   $in (a $uint<32> b $uint<10>)
   $out (c $uint<32>)
$is
{
   c := (mem[b] + a)
   mem[b] := c
}
\end{verbatim}
This consists of a single module, which accumulates
a value into an array position.


An example which is a little bit more complicated:
\begin{verbatim}
// an array of 32-bit unsigned integers.
$declare $storage mem $array<1024> $of $uint<32> 

// module returns the sum of mem[I] from
// I=low to I=high
$module [sum_mod]
    $in (low $uint<10> high $uint<10>)
    $out (sum $uint<32>)
$is
{
 
   d := (high-low)  
   mp := ((high-low)/2)


   $branchblock[trivcheck]
    {
       // d from parent scope
       $if (d > 0) $then  
           // do two summations in parallel
           // parallel summations
           $parallelblock[parsum]
           {
               $branchblock[sb1]{
                    $declare $storage  I $uint<10> := 0
                    $merge $entry loopback
                       $phi s := 0 $on $entry  s1 $on loopback
                    $endmerge
                    $if (I < mp) $then
                       I := (I+1)
                       s1 := ($mux (I == 0)  0 (s + mem[I]))
                       $place [loopback]
                    $endif
               } 
               $branchblock[sb2]{
                    $declare $storage  J $uint<10> := 0
                    J := (mp + 1)
                    $merge $entry loopback
                       $phi s := 0 $on $entry s1 $on loopback
                    $endmerge
                    $if (J < high) $then
                         J := (J+1)
                         s1 := ($mux (J == (mp+1))  0 (s + mem[J]))
                         $place [loopback]
                    $endif
               } 
           }
 
           // combine results from parallel statement above
           snontriv := (%parsum%sb1:s  + %parsum%sb2:s)
           $place [nontrivsum]
      $else

           // summation is trivial 
           striv := mem[low]
           $place [trivsum]
      $endif
      $merge nontrivsum trivsum
         // which sum do you pick? depends on which path was taken
         $phi sum := snontriv $on nontrivsum strivsum $on trivsum
      $endmerge
    }

    // bring sum up to the surface.
    sum := %trivcheck:sum
}
\end{verbatim}
This example describes an algorithm which computes the sum of
a section of an array by dividing the problem into two partial
summations. 

\section{Syntax} \label{sec:Syntax}

The syntax for \Aa follows the following
principles
\begin{itemize}
\item All keywords begin with the \$ sign.
\item The region between \{ and \} defines a new scope.
\item Statements are space separated (no semicolons at all).
\item Expressions are fully parenthitized.  Thus
$(a + b)$ is a legal expression, but $a+b$ is not.
\end{itemize}


The parser is implemented using 
an LL(k) parser (written as rules to be parsed by antlr2 \cite{ref:antlr2}).
The grammar for the parser is (using the EBNF notation) given below. 
\input{AaParser}

This is the set of tokens recognized by the lexical analyzer (or lexer).
\input{AaLexer}

\begin{thebibliography}{99}
\bibitem{ref:SameerPhD}
Sameer D. Sahasrabuddhe,
``A competitive pathway from high-level programs to hardware,''
Ph.D. thesis, IIT Bombay, 2009.

\bibitem{ref:antlr2}
http://www.antlr2.org.
\end{thebibliography}

\end{document}
 







