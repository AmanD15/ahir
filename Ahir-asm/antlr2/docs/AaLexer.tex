\begin{verbatim}


Definition of lexer AaLexer, which is a subclass of CharScanner.

/** Lexer nextToken rule:
 *  The lexer nextToken rule is synthesized from all of the user-defined
 *  lexer rules.  It logically consists of one big alternative block with
 *  each user-defined rule being an alternative.
 */
mMODULE 
|	mDECLARE 
|	mDEFAULT 
|	mSTORAGE 
|	mPIPE 
|	mCONSTANT 
|	mSERIESBLOCK 
|	mPARALLELBLOCK 
|	mFORKBLOCK 
|	mBRANCHBLOCK 
|	mPLACE 
|	mSWITCH 
|	mENDSWITCH 
|	mIF 
|	mENDIF 
|	mOF 
|	mON 
|	mTHEN 
|	mELSE 
|	mFORK 
|	mJOIN 
|	mMERGE 
|	mENDMERGE 
|	mENDJOIN 
|	mWHEN 
|	mENTRY 
|	mEXIT 
|	mFIN 
|	mIN 
|	mOUT 
|	mIS 
|	mASSIGN 
|	mCALL 
|	mPHI 
|	mCOLON 
|	mSEMICOLON 
|	mCOMMA 
|	mQUOTE 
|	mHASH 
|	mASSIGNEQUAL 
|	mEQUAL 
|	mNOTEQUAL 
|	mLESS 
|	mLESSEQUAL 
|	mQUESTION 
|	mGREATER 
|	mGREATEREQUAL 
|	mIMPLIES 
|	mSHL 
|	mSHR 
|	mLBRACE 
|	mRBRACE 
|	mLBRACKET 
|	mRBRACKET 
|	mLPAREN 
|	mRPAREN 
|	mPERCENT 
|	mCARET 
|	mPLUS 
|	mMINUS 
|	mMUL 
|	mDIV 
|	mNOT 
|	mOR 
|	mAND 
|	mXOR 
|	mNOR 
|	mNAND 
|	mXNOR 
|	mMUX 
|	mUINT 
|	mINT 
|	mFLOAT 
|	mPOINTER 
|	mNuLL 
|	mARRAY 
|	mCAST 
|	mUINTEGER 
|	mUFLOAT 
|	mWHITESPACE 
|	mSINGLELINECOMMENT 
|	mSCOPE_IDENTIFIER 
|	mSIMPLE_IDENTIFIER 
mMODULE
	:	"$module" 
	;

mDECLARE
	:	"$declare" 
	;

mDEFAULT
	:	"$default" 
	;

mSTORAGE
	:	"$storage" 
	;

mPIPE
	:	"$pipe" 
	;

mCONSTANT
	:	"$constant" 
	;

mSERIESBLOCK
	:	"$seriesblock" 
	;

mPARALLELBLOCK
	:	"$parallelblock" 
	;

mFORKBLOCK
	:	"$forkblock" 
	;

mBRANCHBLOCK
	:	"$branchblock" 
	;

mPLACE
	:	"$place" 
	;

mSWITCH
	:	"$switch" 
	;

mENDSWITCH
	:	"$endswitch" 
	;

mIF
	:	"$if" 
	;

mENDIF
	:	"$endif" 
	;

mOF
	:	"$of" 
	;

mON
	:	"$on" 
	;

mTHEN
	:	"$then" 
	;

mELSE
	:	"$else" 
	;

mFORK
	:	"$fork" 
	;

mJOIN
	:	"$join" 
	;

mMERGE
	:	"$merge" 
	;

mENDMERGE
	:	"$endmerge" 
	;

mENDJOIN
	:	"$endjoin" 
	;

mWHEN
	:	"$when" 
	;

mENTRY
	:	"$entry" 
	;

mEXIT
	:	"$exit" 
	;

mFIN
	:	"$fin" 
	;

mIN
	:	"$in" 
	;

mOUT
	:	"$out" 
	;

mIS
	:	"$is" 
	;

mASSIGN
	:	"$assign" 
	;

mCALL
	:	"$call" 
	;

mPHI
	:	"$phi" 
	;

mCOLON
	:	':' 
	;

mSEMICOLON
	:	';' 
	;

mCOMMA
	:	',' 
	;

mQUOTE
	:	'"' 
	;

mHASH
	:	'#' 
	;

mASSIGNEQUAL
	:	":=" 
	;

mEQUAL
	:	"==" 
	;

mNOTEQUAL
	:	"!=" 
	;

mLESS
	:	'<' 
	;

mLESSEQUAL
	:	"<=" 
	;

mQUESTION
	:	'?' 
	;

mGREATER
	:	">" 
	;

mGREATEREQUAL
	:	">=" 
	;

mIMPLIES
	:	"=>" 
	;

mSHL
	:	"<<" 
	;

mSHR
	:	">>" 
	;

mLBRACE
	:	'{' 
	;

mRBRACE
	:	'}' 
	;

mLBRACKET
	:	'[' 
	;

mRBRACKET
	:	']' 
	;

mLPAREN
	:	'(' 
	;

mRPAREN
	:	')' 
	;

mPERCENT
	:	'%' 
	;

mCARET
	:	'^' 
	;

mPLUS
	:	'+' 
	;

mMINUS
	:	'-' 
	;

mMUL
	:	'*' 
	;

mDIV
	:	'/' 
	;

mNOT
	:	"$not" 
	;

mOR
	:	"$or" 
	;

mAND
	:	"$and" 
	;

mXOR
	:	"$xor" 
	;

mNOR
	:	"$nor" 
	;

mNAND
	:	"$nand" 
	;

mXNOR
	:	"$xnor" 
	;

mMUX
	:	"$mux" 
	;

mUINT
	:	"$uint" 
	;

mINT
	:	"$int" 
	;

mFLOAT
	:	"$float" 
	;

mPOINTER
	:	"$pointer" 
	;

mNuLL
	:	"$null" 
	;

mARRAY
	:	"$array" 
	;

mCAST
	:	"$cast" 
	;

mUINTEGER
	:	mDIGIT ( mDIGIT )* 
	;

protected mDIGIT
	:			'0'..'9' 
	;

mUFLOAT
	:	'.' mUINTEGER 'E' 
		(	'+' 
		|	'-' 
		) 
		mUINTEGER 
	;

mWHITESPACE
	:	(	' ' 
		|	'\t' 
		|	'\f' 
		|	'\r' 
		|	'\n' 
		) 
		
	;

mSINGLELINECOMMENT
	:	( "//" ( ~'\n' )* '\n' ) 
	;

mSCOPE_IDENTIFIER
	:	'.' ( mSIMPLE_IDENTIFIER '.' )* 
	;

mSIMPLE_IDENTIFIER
	:	mALPHA 
		(	mALPHA 
		|	mDIGIT 
		|	'_' 
		)* 
	;

protected mALPHA
	:			'a'..'z' 
	|			'A'..'Z' 
	;

\end{verbatim}

