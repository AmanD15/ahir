
\begin{verbatim}


Definition of parser AaParser, which is a subclass of LLkParser.


aA_Program
	:	(	( aA_Module ) 
		|	( DECLARE ( aA_Object_Declaration )+ ) 
		)* 
	;


aA_Module
	:	MODULE aA_Label aA_In_Args aA_Out_Args IS LBRACE 
		(	DECLARE ( aA_Object_Declaration )+ 
		|	
		) 
		aA_Atomic_Statement_Sequence RBRACE 
	;


aA_Object_Declaration
	:	( aA_Storage_Object_Declaration ) 
	|	( aA_Constant_Object_Declaration ) 
	|	( aA_Pipe_Object_Declaration ) 
	;


aA_Label
	:	( LBRACKET ) ( SIMPLE_IDENTIFIER ) ( RBRACKET ) 
	;


aA_In_Args
	:	IN LPAREN ( aA_Interface_Object_Declaration )* RPAREN 
	;


aA_Out_Args
	:	OUT LPAREN ( aA_Interface_Object_Declaration )* RPAREN 
	;


aA_Atomic_Statement_Sequence
	:	( aA_Atomic_Statement )+ 
	;


aA_Interface_Object_Declaration
	:	( aA_Object_Declaration_Base ) 
	;


aA_Atomic_Statement
	:	aA_Assignment_Statement 
	|	aA_Call_Statement 
	|	aA_Null_Statement 
	|	aA_Block_Statement 
	;


aA_Assignment_Statement
	:	( aA_Object_Reference ) ASSIGNEQUAL ( aA_Expression ) 
	;


aA_Call_Statement
	:	CALL SIMPLE_IDENTIFIER aA_Argv_In aA_Argv_Out 
	;


aA_Null_Statement
	:	NuLL 
	;


aA_Block_Statement
	:	aA_Series_Block_Statement 
	|	aA_Parallel_Block_Statement 
	|	aA_Fork_Block_Statement 
	|	aA_Branch_Block_Statement 
	;


aA_Object_Reference
	:	(	(	( PERCENT SIMPLE_IDENTIFIER )* 
			|	( CARET )+ 
			) 
			COLON 
		|	
		) 
		( SIMPLE_IDENTIFIER ) ( LBRACKET aA_Expression RBRACKET )* 
	;


aA_Expression
	:	(	( aA_Constant_Literal_Reference ) 
		|	( aA_Object_Reference ) 
		|	( aA_Unary_Expression ) 
		|	( aA_Binary_Expression ) 
		|	( aA_Ternary_Expression ) 
		) 
	;


aA_Argv_In
	:	LPAREN ( aA_Object_Reference )* RPAREN 
	;


aA_Argv_Out
	:	LPAREN ( SIMPLE_IDENTIFIER )* RPAREN 
	;


aA_Series_Block_Statement
	:	SERIESBLOCK 
		(	aA_Label 
		|	
		) 
		LBRACE 
		(	DECLARE ( aA_Object_Declaration )+ 
		|	
		) 
		aA_Atomic_Statement_Sequence RBRACE 
	;


aA_Parallel_Block_Statement
	:	PARALLELBLOCK 
		(	aA_Label 
		|	
		) 
		LBRACE 
		(	DECLARE ( aA_Object_Declaration )+ 
		|	
		) 
		aA_Atomic_Statement_Sequence RBRACE 
	;


aA_Fork_Block_Statement
	:	FORKBLOCK 
		(	aA_Label 
		|	
		) 
		LBRACE 
		(	DECLARE ( aA_Object_Declaration )+ 
		|	
		) 
		aA_Fork_Block_Statement_Sequence RBRACE 
	;


aA_Branch_Block_Statement
	:	BRANCHBLOCK 
		(	aA_Label 
		|	
		) 
		LBRACE 
		(	DECLARE ( aA_Object_Declaration )+ 
		|	
		) 
		aA_Branch_Block_Statement_Sequence RBRACE 
	;


aA_Fork_Block_Statement_Sequence
	:	(	( aA_Join_Fork_Statement ) 
		|	( aA_Atomic_Statement ) 
		)+ 
		
	;


aA_Join_Fork_Statement
	:	JOIN ( SIMPLE_IDENTIFIER )* 
		(	AND FORK aA_Atomic_Statement_Sequence 
		|	
		) 
		ENDJOIN 
	;


aA_Branch_Block_Statement_Sequence
	:	( (	( aA_Merge_Statement ) 
			|	( (	aA_Switch_Statement 
					|	aA_If_Statement 
					) ) 
			|	( aA_Atomic_Statement ) 
			|	( aA_Place_Statement ) 
			) 
			)+ 
	;


aA_Merge_Statement
	:	MERGE 
		(	( SIMPLE_IDENTIFIER ) 
		|	( ENTRY ) 
		)+ 
		(	( aA_Phi_Statement )+ 
		|	
		) 
		ENDMERGE 
	;


aA_Switch_Statement
	:	SWITCH aA_Expression ( WHEN aA_Constant_Literal_Reference THEN aA_Branch_Block_Statement_Sequence )* 
		(	DEFAULT aA_Branch_Block_Statement_Sequence 
		|	
		) 
		ENDSWITCH 
	;


aA_If_Statement
	:	IF ( aA_Expression ) THEN aA_Branch_Block_Statement_Sequence 
		(	ELSE aA_Branch_Block_Statement_Sequence 
		|	
		) 
		ENDIF 
	;


aA_Place_Statement
	:	PLACE aA_Label 
	;


aA_Block_Statement_Sequence
	:	( aA_Block_Statement )+ 
	;


aA_Phi_Statement
	:	PHI SIMPLE_IDENTIFIER ASSIGNEQUAL ( aA_Expression ON 
			(	( SIMPLE_IDENTIFIER ) 
			|	( ENTRY ) 
			) 
			)+ 
	;


aA_Constant_Literal_Reference
	:	(	PLUS 
		|	MINUS 
		|	
		) 
		(	(	( UINTEGER ) 
			|	( UFLOAT ) 
			) 
		|	( LESS 
				(	( UINTEGER )+ 
				|	( UFLOAT )+ 
				) 
				GREATER ) 
		) 
		
	;


aA_Unary_Expression
	:	LPAREN 
		(	( ( NOT ) ( aA_Expression ) ) 
		|	( CAST LPAREN ( aA_Type_Reference ) RPAREN ( aA_Expression ) ) 
		) 
		RPAREN 
	;


aA_Binary_Expression
	:	LPAREN aA_Expression aA_Binary_Op aA_Expression RPAREN 
	;


aA_Ternary_Expression
	:	LPAREN MUX aA_Expression ( aA_Expression ) ( aA_Expression ) RPAREN 
	;


aA_Type_Reference
	:	( aA_Scalar_Type_Reference ) 
	|	( aA_Array_Type_Reference ) 
	;


aA_Binary_Op
	:	( OR ) 
	|	( AND ) 
	|	( NOR ) 
	|	( NAND ) 
	|	( XOR ) 
	|	( XNOR ) 
	|	( SHL ) 
	|	( SHR ) 
	|	( PLUS ) 
	|	( MINUS ) 
	|	( DIV ) 
	|	( MUL ) 
	|	( EQUAL ) 
	|	( NOTEQUAL ) 
	|	( LESS ) 
	|	( LESSEQUAL ) 
	|	( GREATER ) 
	|	( GREATEREQUAL ) 
	;


aA_Storage_Object_Declaration
	:	( STORAGE aA_Object_Declaration_Base ) 
	;


aA_Constant_Object_Declaration
	:	( CONSTANT aA_Object_Declaration_Base ) 
	;


aA_Pipe_Object_Declaration
	:	( PIPE aA_Object_Declaration_Base ) 
	;


aA_Object_Declaration_Base
	:	( SIMPLE_IDENTIFIER ) ( aA_Type_Reference ) 
		(	ASSIGNEQUAL aA_Constant_Literal_Reference 
		|	
		) 
	;


aA_Scalar_Type_Reference
	:	( aA_Uint_Type_Reference ) 
	|	( aA_Int_Type_Reference ) 
	|	( aA_Float_Type_Reference ) 
	|	( aA_Pointer_Type_Reference ) 
	;


aA_Uint_Type_Reference
	:	UINT LESS UINTEGER GREATER 
	;


aA_Int_Type_Reference
	:	INT LESS UINTEGER GREATER 
	;


aA_Float_Type_Reference
	:	FLOAT LESS UINTEGER COMMA UINTEGER GREATER 
	;


aA_Pointer_Type_Reference
	:	POINTER LESS UINTEGER GREATER 
	;


aA_Array_Type_Reference
	:	ARRAY ( LESS UINTEGER GREATER )+ OF ( aA_Scalar_Type_Reference ) 
	;


\end{verbatim}

